/*
 * Generated automatically from cf.data by ./cf_gen
 *
 * Abstract: This file contains routines used to configure the
 *           variables in the squid server.
 */

static void
default_line(const char *s)
{
    LOCAL_ARRAY(char, tmp_line, BUFSIZ);
    xstrncpy(tmp_line, s, BUFSIZ);
    xstrncpy(config_input_line, s, BUFSIZ);
    config_lineno++;
    parse_line(tmp_line);
}

static void
default_all(void)
{
    cfg_filename = "Default Configuration";
    config_lineno = 0;
    default_line("workers 1");
    // No default for cpu_affinity_map
    // No default for auth_param
    default_line("authenticate_cache_garbage_interval 1 hour");
    default_line("authenticate_ttl 1 hour");
    default_line("authenticate_ip_ttl 1 second");
    // No default for external_acl_type
    default_line("acl all src all");
    default_line("acl manager url_regex -i ^cache_object:// +i ^https?://[^/]+/squid-internal-mgr/");
    default_line("acl localhost src 127.0.0.1/32 ::1");
    default_line("acl to_localhost dst 127.0.0.0/8 0.0.0.0/32 ::1");
    // No default for proxy_protocol_access
    // No default for follow_x_forwarded_for
#if FOLLOW_X_FORWARDED_FOR
    default_line("acl_uses_indirect_client on");
#endif
#if FOLLOW_X_FORWARDED_FOR&&USE_DELAY_POOLS
    default_line("delay_pool_uses_indirect_client on");
#endif
#if FOLLOW_X_FORWARDED_FOR
    default_line("log_uses_indirect_client on");
#endif
#if FOLLOW_X_FORWARDED_FOR&&LINUX_NETFILTER
    default_line("tproxy_uses_indirect_client off");
#endif
    // No default for spoof_client_ip
    // No default for http_access
    // No default for adapted_http_access
    // No default for http_reply_access
    // No default for icp_access
    // No default for htcp_access
    // No default for htcp_clr_access
    // No default for miss_access
    // No default for ident_lookup_access
    // No default for reply_body_max_size
    // No default for http_port
    // No default for https_port
    // No default for ftp_port
    // No default for tcp_outgoing_tos
    // No default for clientside_tos
    // No default for tcp_outgoing_mark
    // No default for clientside_mark
    // No default for qos_flows
    // No default for tcp_outgoing_address
    default_line("host_verify_strict off");
    default_line("client_dst_passthru on");
#if USE_OPENSSL
    default_line("ssl_unclean_shutdown off");
#endif
    // No default for ssl_engine
    // No default for sslproxy_client_certificate
    // No default for sslproxy_client_key
#if USE_OPENSSL
    default_line("sslproxy_version 1");
#endif
    // No default for sslproxy_options
    // No default for sslproxy_cipher
    // No default for sslproxy_cafile
    // No default for sslproxy_capath
#if USE_OPENSSL
    default_line("sslproxy_session_ttl 300");
#endif
#if USE_OPENSSL
    default_line("sslproxy_session_cache_size 2 MB");
#endif
    // No default for sslproxy_foreign_intermediate_certs
    // No default for sslproxy_cert_sign_hash
    // No default for ssl_bump
    // No default for sslproxy_flags
    // No default for sslproxy_cert_error
    // No default for sslproxy_cert_sign
    // No default for sslproxy_cert_adapt
    // No default for sslpassword_program
#if USE_SSL_CRTD
    default_line("sslcrtd_program /usr/local/squid/libexec/ssl_crtd -s /usr/local/squid/var/lib/ssl_db -M 4MB");
#endif
#if USE_SSL_CRTD
    default_line("sslcrtd_children 32 startup=5 idle=1");
#endif
    // No default for sslcrtvalidator_program
#if USE_OPENSSL
    default_line("sslcrtvalidator_children 32 startup=5 idle=1 concurrency=1");
#endif
    // No default for cache_peer
    // No default for cache_peer_domain
    // No default for cache_peer_access
    // No default for neighbor_type_domain
    default_line("dead_peer_timeout 10 seconds");
    default_line("forward_max_tries 25");
    default_line("cache_mem 256 MB");
    default_line("maximum_object_size_in_memory 512 KB");
    // No default for memory_cache_shared
    default_line("memory_cache_mode always");
    default_line("memory_replacement_policy lru");
    default_line("cache_replacement_policy lru");
    default_line("minimum_object_size 0 KB");
    default_line("maximum_object_size 4 MB");
    // No default for cache_dir
    default_line("store_dir_select_algorithm least-load");
    default_line("max_open_disk_fds 0");
    default_line("cache_swap_low 90");
    default_line("cache_swap_high 95");
    // No default for logformat
    // No default for access_log
    // No default for icap_log
    default_line("logfile_daemon /usr/local/squid/libexec/log_file_daemon");
    // No default for stats_collection
    // No default for cache_store_log
    // No default for cache_swap_state
    default_line("logfile_rotate 10");
    default_line("mime_table /usr/local/squid/etc/mime.conf");
    default_line("log_mime_hdrs off");
    default_line("pid_filename /usr/local/squid/var/run/squid.pid");
    default_line("client_netmask no_addr");
    default_line("strip_query_terms on");
    default_line("buffered_logs off");
#if USE_ICMP
    default_line("netdb_filename stdio:/usr/local/squid/var/logs/netdb.state");
#endif
    // No default for cache_log
    default_line("debug_options ALL,1");
    // No default for coredump_dir
    default_line("ftp_user Squid@");
    default_line("ftp_passive on");
    default_line("ftp_epsv_all off");
    // No default for ftp_epsv
    default_line("ftp_eprt on");
    default_line("ftp_sanitycheck on");
    default_line("ftp_telnet_protocol on");
    default_line("diskd_program /usr/local/squid/libexec/diskd");
#if USE_UNLINKD
    default_line("unlinkd_program /usr/local/squid/libexec/unlinkd");
#endif
#if USE_ICMP
    default_line("pinger_program /usr/local/squid/libexec/pinger");
#endif
#if USE_ICMP
    default_line("pinger_enable on");
#endif
    // No default for url_rewrite_program
    default_line("url_rewrite_children 20 startup=0 idle=1 concurrency=0");
    default_line("url_rewrite_host_header on");
    // No default for url_rewrite_access
    default_line("url_rewrite_bypass off");
    default_line("url_rewrite_extras \"%>a/%>A %un %>rm myip=%la myport=%lp\"");
    // No default for store_id_program
    default_line("store_id_extras \"%>a/%>A %un %>rm myip=%la myport=%lp\"");
    default_line("store_id_children 20 startup=0 idle=1 concurrency=0");
    // No default for store_id_access
    default_line("store_id_bypass on");
    // No default for cache
    // No default for send_hit
    // No default for store_miss
    default_line("max_stale 1 week");
    // No default for refresh_pattern
    default_line("quick_abort_min 16 KB");
    default_line("quick_abort_max 16 KB");
    default_line("quick_abort_pct 95");
    default_line("read_ahead_gap 16 KB");
#if USE_HTTP_VIOLATIONS
    default_line("negative_ttl 0 seconds");
#endif
    default_line("positive_dns_ttl 6 hours");
    default_line("negative_dns_ttl 1 minutes");
    // No default for range_offset_limit
    default_line("minimum_expiry_time 60 seconds");
    default_line("store_avg_object_size 13 KB");
    default_line("store_objects_per_bucket 20");
    default_line("request_header_max_size 64 KB");
    default_line("reply_header_max_size 64 KB");
    default_line("request_body_max_size 0 KB");
    default_line("client_request_buffer_max_size 512 KB");
    // No default for broken_posts
#if FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION
    default_line("adaptation_uses_indirect_client on");
#endif
#if USE_HTTP_VIOLATIONS
    default_line("via on");
#endif
    default_line("ie_refresh off");
    default_line("vary_ignore_expire off");
    default_line("request_entities off");
    // No default for request_header_access
    // No default for reply_header_access
    // No default for request_header_replace
    // No default for reply_header_replace
    // No default for request_header_add
    // No default for note
    default_line("relaxed_header_parser on");
    default_line("collapsed_forwarding off");
    default_line("forward_timeout 4 minutes");
    default_line("connect_timeout 1 minute");
    default_line("peer_connect_timeout 30 seconds");
    default_line("read_timeout 15 minutes");
    default_line("write_timeout 15 minutes");
    default_line("request_timeout 5 minutes");
    default_line("client_idle_pconn_timeout 2 minutes");
    default_line("ftp_client_idle_timeout 30 minutes");
    default_line("client_lifetime 1 day");
    default_line("half_closed_clients off");
    default_line("server_idle_pconn_timeout 1 minute");
#if USE_IDENT
    default_line("ident_timeout 10 seconds");
#endif
    default_line("shutdown_lifetime 30 seconds");
    default_line("cache_mgr webmaster");
    // No default for mail_from
    default_line("mail_program mail");
    default_line("cache_effective_user nobody");
    // No default for cache_effective_group
    default_line("httpd_suppress_version_string off");
    // No default for visible_hostname
    // No default for unique_hostname
    // No default for hostname_aliases
    default_line("umask 027");
    default_line("announce_period 0");
    default_line("announce_host tracker.ircache.net");
    // No default for announce_file
    default_line("announce_port 3131");
    // No default for httpd_accel_surrogate_id
    default_line("http_accel_surrogate_remote off");
#if USE_SQUID_ESI
    default_line("esi_parser custom");
#endif
#if USE_DELAY_POOLS
    default_line("delay_pools 0");
#endif
    // No default for delay_class
    // No default for delay_access
    // No default for delay_parameters
#if USE_DELAY_POOLS
    default_line("delay_initial_bucket_level 50");
#endif
#if USE_DELAY_POOLS
    default_line("client_delay_pools 0");
#endif
#if USE_DELAY_POOLS
    default_line("client_delay_initial_bucket_level 50");
#endif
    // No default for client_delay_parameters
    // No default for client_delay_access
#if USE_WCCP
    default_line("wccp_router any_addr");
#endif
    // No default for wccp2_router
#if USE_WCCP
    default_line("wccp_version 4");
#endif
#if USE_WCCPv2
    default_line("wccp2_rebuild_wait on");
#endif
#if USE_WCCPv2
    default_line("wccp2_forwarding_method gre");
#endif
#if USE_WCCPv2
    default_line("wccp2_return_method gre");
#endif
#if USE_WCCPv2
    default_line("wccp2_assignment_method hash");
#endif
    // No default for wccp2_service
    // No default for wccp2_service_info
#if USE_WCCPv2
    default_line("wccp2_weight 10000");
#endif
#if USE_WCCP
    default_line("wccp_address 0.0.0.0");
#endif
#if USE_WCCPv2
    default_line("wccp2_address 0.0.0.0");
#endif
    default_line("client_persistent_connections on");
    default_line("server_persistent_connections on");
    default_line("persistent_connection_after_error on");
    default_line("detect_broken_pconn off");
#if USE_CACHE_DIGESTS
    default_line("digest_generation on");
#endif
#if USE_CACHE_DIGESTS
    default_line("digest_bits_per_entry 5");
#endif
#if USE_CACHE_DIGESTS
    default_line("digest_rebuild_period 1 hour");
#endif
#if USE_CACHE_DIGESTS
    default_line("digest_rewrite_period 1 hour");
#endif
#if USE_CACHE_DIGESTS
    default_line("digest_swapout_chunk_size 4096 bytes");
#endif
#if USE_CACHE_DIGESTS
    default_line("digest_rebuild_chunk_percentage 10");
#endif
#if SQUID_SNMP
    default_line("snmp_port 0");
#endif
    // No default for snmp_access
#if SQUID_SNMP
    default_line("snmp_incoming_address any_addr");
#endif
#if SQUID_SNMP
    default_line("snmp_outgoing_address no_addr");
#endif
    default_line("icp_port 0");
#if USE_HTCP
    default_line("htcp_port 0");
#endif
    default_line("log_icp_queries on");
    default_line("udp_incoming_address any_addr");
    default_line("udp_outgoing_address no_addr");
    default_line("icp_hit_stale off");
    default_line("minimum_direct_hops 4");
    default_line("minimum_direct_rtt 400");
    default_line("netdb_low 900");
    default_line("netdb_high 1000");
    default_line("netdb_ping_period 5 minutes");
    default_line("query_icmp off");
    default_line("test_reachability off");
    default_line("icp_query_timeout 0");
    default_line("maximum_icp_query_timeout 2000");
    default_line("minimum_icp_query_timeout 5");
    default_line("background_ping_rate 10 seconds");
    // No default for mcast_groups
#if MULTICAST_MISS_STREAM
    default_line("mcast_miss_addr no_addr");
#endif
#if MULTICAST_MISS_STREAM
    default_line("mcast_miss_ttl 16");
#endif
#if MULTICAST_MISS_STREAM
    default_line("mcast_miss_port 3135");
#endif
#if MULTICAST_MISS_STREAM
    default_line("mcast_miss_encode_key XXXXXXXXXXXXXXXX");
#endif
    default_line("mcast_icp_query_timeout 2000");
    default_line("icon_directory /usr/local/squid/share/icons");
    default_line("global_internal_static on");
    default_line("short_icon_urls on");
    // No default for error_directory
    // No default for error_default_language
#if USE_ERR_LOCALES
    default_line("error_log_languages on");
#endif
    default_line("err_page_stylesheet /usr/local/squid/etc/errorpage.css");
    // No default for err_html_text
    default_line("email_err_data on");
    // No default for deny_info
    default_line("nonhierarchical_direct on");
    default_line("prefer_direct off");
    default_line("cache_miss_revalidate on");
    // No default for always_direct
    // No default for never_direct
    default_line("incoming_udp_average 6");
    default_line("incoming_tcp_average 4");
    default_line("incoming_dns_average 4");
    default_line("min_udp_poll_cnt 8");
    default_line("min_dns_poll_cnt 8");
    default_line("min_tcp_poll_cnt 8");
    // No default for accept_filter
    default_line("client_ip_max_connections -1");
    default_line("tcp_recv_bufsize 0 bytes");
#if ICAP_CLIENT
    default_line("icap_enable off");
#endif
    // No default for icap_connect_timeout
    // No default for icap_io_timeout
#if ICAP_CLIENT
    default_line("icap_service_failure_limit 10");
#endif
#if ICAP_CLIENT
    default_line("icap_service_revival_delay 180");
#endif
#if ICAP_CLIENT
    default_line("icap_preview_enable on");
#endif
#if ICAP_CLIENT
    default_line("icap_preview_size -1");
#endif
#if ICAP_CLIENT
    default_line("icap_206_enable on");
#endif
#if ICAP_CLIENT
    default_line("icap_default_options_ttl 60");
#endif
#if ICAP_CLIENT
    default_line("icap_persistent_connections on");
#endif
#if USE_ADAPTATION
    default_line("adaptation_send_client_ip off");
#endif
#if USE_ADAPTATION
    default_line("adaptation_send_username off");
#endif
#if ICAP_CLIENT
    default_line("icap_client_username_header X-Client-Username");
#endif
#if ICAP_CLIENT
    default_line("icap_client_username_encode off");
#endif
    // No default for icap_service
    // No default for icap_class
    // No default for icap_access
#if USE_ECAP
    default_line("ecap_enable off");
#endif
    // No default for ecap_service
    // No default for loadable_modules
    // No default for adaptation_service_set
    // No default for adaptation_service_chain
    // No default for adaptation_access
#if USE_ADAPTATION
    default_line("adaptation_service_iteration_limit 16");
#endif
    // No default for adaptation_masterx_shared_names
    // No default for adaptation_meta
    // No default for icap_retry
#if ICAP_CLIENT
    default_line("icap_retry_limit 0");
#endif
    default_line("check_hostnames off");
    default_line("allow_underscore on");
    default_line("dns_retransmit_interval 5 seconds");
    default_line("dns_timeout 30 seconds");
    // No default for dns_packet_max
    default_line("dns_defnames off");
    default_line("dns_multicast_local off");
    // No default for dns_nameservers
    default_line("hosts_file /etc/hosts");
    // No default for append_domain
    default_line("ignore_unknown_nameservers on");
    default_line("dns_v4_first off");
    default_line("ipcache_size 1024");
    default_line("ipcache_low 90");
    default_line("ipcache_high 95");
    default_line("fqdncache_size 1024");
    default_line("configuration_includes_quoted_values off");
    default_line("memory_pools on");
    default_line("memory_pools_limit 5 MB");
    default_line("forwarded_for on");
    // No default for cachemgr_passwd
    default_line("client_db on");
    default_line("refresh_all_ims off");
#if USE_HTTP_VIOLATIONS
    default_line("reload_into_ims off");
#endif
    default_line("connect_retries 0");
    default_line("retry_on_error off");
    default_line("as_whois_server whois.ra.net");
    default_line("offline_mode off");
    default_line("uri_whitespace strip");
    // No default for chroot
    default_line("balance_on_multiple_ip off");
    default_line("pipeline_prefetch 0");
    default_line("high_response_time_warning 0");
    default_line("high_page_fault_warning 0");
#if HAVE_MSTATS&&HAVE_GNUMALLOC_H
    default_line("high_memory_warning 0 KB");
#endif
    default_line("sleep_after_fork 0");
#if _SQUID_WINDOWS_
    default_line("windows_ipaddrchangemonitor on");
#endif
#if USE_SQUID_EUI
    default_line("eui_lookup on");
#endif
    default_line("max_filedescriptors 0");
    cfg_filename = NULL;
}

static void
defaults_if_none(void)
{
    cfg_filename = "Default Configuration (if absent)";
    config_lineno = 0;
#if FOLLOW_X_FORWARDED_FOR
    if (check_null_acl_access(Config.accessList.followXFF)) {
        default_line("follow_x_forwarded_for deny all");
    }
#endif
    if (check_null_acl_access(Config.accessList.http)) {
        default_line("http_access deny all");
    }
    if (check_null_access_log(Config.Log.accesslogs)) {
        default_line("access_log daemon:/usr/local/squid/var/logs/access.log squid");
    }
    if (check_null_string(Debug::cache_log)) {
        default_line("cache_log /usr/local/squid/var/logs/cache.log");
    }
    if (check_null_string(Config.coredump_dir)) {
        default_line("coredump_dir none");
    }
#if USE_WCCPv2
    if (check_null_wccp2_service(Config.Wccp2.info)) {
        default_line("wccp2_service standard 0");
    }
#endif
#if ICAP_CLIENT
    if (check_null_acl_access(Adaptation::Icap::TheConfig.repeat)) {
        default_line("icap_retry deny all");
    }
#endif
    cfg_filename = NULL;
}

static void
defaults_postscriptum(void)
{
    cfg_filename = "Default Configuration (postscriptum)";
    config_lineno = 0;
#if USE_OPENSSL
    default_line("sslproxy_cert_sign signUntrusted ssl::certUntrusted");
    default_line("sslproxy_cert_sign signSelf ssl::certSelfSigned");
    default_line("sslproxy_cert_sign signTrusted all");
#endif
    cfg_filename = NULL;
}

static int
parse_line(char *buff)
{
	char	*token;
	if ((token = strtok(buff, w_space)) == NULL) 
		return 1;	/* ignore empty lines */
	ConfigParser::SetCfgLine(strtok(NULL, ""));
    if (!strcmp(token, "broken_vary_encoding")) {
        cfg_directive = "broken_vary_encoding";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'broken_vary_encoding' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "broken_vary_encoding : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_vary")) {
        cfg_directive = "cache_vary";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'cache_vary' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "cache_vary : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "error_map")) {
        cfg_directive = "error_map";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'error_map' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "error_map : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "external_refresh_check")) {
        cfg_directive = "external_refresh_check";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'external_refresh_check' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "external_refresh_check : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "location_rewrite_program")) {
        cfg_directive = "location_rewrite_program";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'location_rewrite_program' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "location_rewrite_program : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "location_rewrite_concurrency")) {
        cfg_directive = "location_rewrite_concurrency";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'location_rewrite_concurrency' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "location_rewrite_concurrency : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "location_rewrite_children")) {
        cfg_directive = "location_rewrite_children";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'location_rewrite_children' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "location_rewrite_children : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "location_rewrite_access")) {
        cfg_directive = "location_rewrite_access";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'location_rewrite_access' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "location_rewrite_access : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "refresh_stale_hit")) {
        cfg_directive = "refresh_stale_hit";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'refresh_stale_hit' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "refresh_stale_hit : This option is not yet supported by Squid-3.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "hierarchy_stoplist")) {
        cfg_directive = "hierarchy_stoplist";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'hierarchy_stoplist' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "hierarchy_stoplist : Remove this line. Use always_direct or cache_peer_access ACLs instead if you need to prevent cache_peer use.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "log_access")) {
        cfg_directive = "log_access";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'log_access' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "log_access : Remove this line. Use acls with access_log directives to control access logging");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "log_icap")) {
        cfg_directive = "log_icap";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'log_icap' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "log_icap : Remove this line. Use acls with icap_log directives to control icap logging");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ignore_ims_on_miss")) {
        cfg_directive = "ignore_ims_on_miss";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'ignore_ims_on_miss' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ignore_ims_on_miss : Remove this line. The HTTP/1.1 feature is now configured by 'cache_miss_revalidate'.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "chunked_request_body_max_size")) {
        cfg_directive = "chunked_request_body_max_size";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'chunked_request_body_max_size' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "chunked_request_body_max_size : Remove this line. Squid is now HTTP/1.1 compliant.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "dns_v4_fallback")) {
        cfg_directive = "dns_v4_fallback";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'dns_v4_fallback' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "dns_v4_fallback : Remove this line. Squid performs a 'Happy Eyeballs' algorithm, the 'fallback' algorithm is no longer relevant.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "emulate_httpd_log")) {
        cfg_directive = "emulate_httpd_log";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'emulate_httpd_log' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "emulate_httpd_log : Replace this with an access_log directive using the format 'common' or 'combined'.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "forward_log")) {
        cfg_directive = "forward_log";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'forward_log' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "forward_log : Use a regular access.log with ACL limiting it to MISS events.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ftp_list_width")) {
        cfg_directive = "ftp_list_width";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'ftp_list_width' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ftp_list_width : Remove this line. Configure FTP page display using the CSS controls in errorpages.css instead.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ignore_expect_100")) {
        cfg_directive = "ignore_expect_100";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'ignore_expect_100' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ignore_expect_100 : Remove this line. The HTTP/1.1 feature is now fully supported by default.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "log_fqdn")) {
        cfg_directive = "log_fqdn";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'log_fqdn' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "log_fqdn : Remove this option from your config. To log FQDN use %>A in the log format.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "log_ip_on_direct")) {
        cfg_directive = "log_ip_on_direct";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'log_ip_on_direct' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "log_ip_on_direct : Remove this option from your config. To log server or peer names use %<A in the log format.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "maximum_single_addr_tries")) {
        cfg_directive = "maximum_single_addr_tries";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'maximum_single_addr_tries' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "maximum_single_addr_tries : Replaced by connect_retries. The behaviour has changed, please read the documentation before altering.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "referer_log")) {
        cfg_directive = "referer_log";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'referer_log' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "referer_log : Replace this with an access_log directive using the format 'referrer'.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "referrer_log")) {
        cfg_directive = "referrer_log";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'referrer_log' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "referrer_log : Replace this with an access_log directive using the format 'referrer'.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "update_headers")) {
        cfg_directive = "update_headers";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'update_headers' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "update_headers : Remove this line. The feature is supported by default in storage types where update is implemented.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "url_rewrite_concurrency")) {
        cfg_directive = "url_rewrite_concurrency";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'url_rewrite_concurrency' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "url_rewrite_concurrency : Remove this line. Set the 'concurrency=' option of url_rewrite_children instead.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "useragent_log")) {
        cfg_directive = "useragent_log";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'useragent_log' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "useragent_log : Replace this with an access_log directive using the format 'useragent'.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "dns_testnames")) {
        cfg_directive = "dns_testnames";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'dns_testnames' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "dns_testnames : Remove this line. DNS is no longer tested on startup.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "extension_methods")) {
        cfg_directive = "extension_methods";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'extension_methods' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "extension_methods : Remove this line. All valid methods for HTTP are accepted by default.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "zero_buffers")) {
        cfg_directive = "zero_buffers";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'zero_buffers' is obsolete.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "incoming_rate")) {
        cfg_directive = "incoming_rate";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'incoming_rate' is obsolete.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "server_http11")) {
        cfg_directive = "server_http11";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'server_http11' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "server_http11 : Remove this line. HTTP/1.1 is supported by default.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "upgrade_http0.9")) {
        cfg_directive = "upgrade_http0.9";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'upgrade_http0.9' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "upgrade_http0.9 : Remove this line. ICY/1.0 streaming protocol is supported by default.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "zph_local")) {
        cfg_directive = "zph_local";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'zph_local' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "zph_local : Alter these entries. Use the qos_flows directive instead.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "zph_sibling")) {
        cfg_directive = "zph_sibling";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'zph_sibling' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "zph_sibling : Alter these entries. Use the qos_flows directive instead.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "zph_parent")) {
        cfg_directive = "zph_parent";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'zph_parent' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "zph_parent : Alter these entries. Use the qos_flows directive instead.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "zph_option")) {
        cfg_directive = "zph_option";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'zph_option' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "zph_option : Alter these entries. Use the qos_flows directive instead.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "zph_mode")) {
        cfg_directive = "zph_mode";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'zph_mode' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "zph_mode : Alter these entries. Use the qos_flows directive instead.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "header_access")) {
        cfg_directive = "header_access";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'header_access' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "header_access : Since squid-3.0 replace with request_header_access or reply_header_access");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "header_access : depending on whether you wish to match client requests or server replies.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "httpd_accel_no_pmtu_disc")) {
        cfg_directive = "httpd_accel_no_pmtu_disc";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'httpd_accel_no_pmtu_disc' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "httpd_accel_no_pmtu_disc : Since squid-3.0 use the 'disable-pmtu-discovery' flag on http_port instead.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "wais_relay_host")) {
        cfg_directive = "wais_relay_host";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'wais_relay_host' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "wais_relay_host : Replace this line with 'cache_peer' configuration.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "wais_relay_port")) {
        cfg_directive = "wais_relay_port";
        debugs(0, DBG_CRITICAL, "ERROR: Directive 'wais_relay_port' is obsolete.");
        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "wais_relay_port : Replace this line with 'cache_peer' configuration.");
        parse_obsolete(token);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "workers")) {
        cfg_directive = "workers";
        parse_int(&Config.workers);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cpu_affinity_map")) {
        cfg_directive = "cpu_affinity_map";
        parse_CpuAffinityMap(&Config.cpuAffinityMap);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "auth_param")) {
#if USE_AUTH
        cfg_directive = "auth_param";
        parse_authparam(&Auth::TheConfig);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'auth_param' requires --enable-auth");
#endif
        return 1;
    };
    if (!strcmp(token, "authenticate_cache_garbage_interval")) {
        cfg_directive = "authenticate_cache_garbage_interval";
        parse_time_t(&Config.authenticateGCInterval);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "authenticate_ttl")) {
        cfg_directive = "authenticate_ttl";
        parse_time_t(&Config.authenticateTTL);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "authenticate_ip_ttl")) {
        cfg_directive = "authenticate_ip_ttl";
        parse_time_t(&Config.authenticateIpTTL);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "external_acl_type")) {
        cfg_directive = "external_acl_type";
        parse_externalAclHelper(&Config.externalAclHelperList);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "acl")) {
        cfg_directive = "acl";
        parse_acl(&Config.aclList);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "proxy_protocol_access")) {
        cfg_directive = "proxy_protocol_access";
        parse_acl_access(&Config.accessList.proxyProtocol);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "follow_x_forwarded_for")) {
#if FOLLOW_X_FORWARDED_FOR
        cfg_directive = "follow_x_forwarded_for";
        parse_acl_access(&Config.accessList.followXFF);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'follow_x_forwarded_for' requires --enable-follow-x-forwarded-for");
#endif
        return 1;
    };
    if (!strcmp(token, "acl_uses_indirect_client")) {
#if FOLLOW_X_FORWARDED_FOR
        cfg_directive = "acl_uses_indirect_client";
        parse_onoff(&Config.onoff.acl_uses_indirect_client);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'acl_uses_indirect_client' requires --enable-follow-x-forwarded-for");
#endif
        return 1;
    };
    if (!strcmp(token, "delay_pool_uses_indirect_client")) {
#if FOLLOW_X_FORWARDED_FOR&&USE_DELAY_POOLS
        cfg_directive = "delay_pool_uses_indirect_client";
        parse_onoff(&Config.onoff.delay_pool_uses_indirect_client);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'delay_pool_uses_indirect_client' requires --enable-follow-x-forwarded-for and --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "log_uses_indirect_client")) {
#if FOLLOW_X_FORWARDED_FOR
        cfg_directive = "log_uses_indirect_client";
        parse_onoff(&Config.onoff.log_uses_indirect_client);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'log_uses_indirect_client' requires --enable-follow-x-forwarded-for");
#endif
        return 1;
    };
    if (!strcmp(token, "tproxy_uses_indirect_client")) {
#if FOLLOW_X_FORWARDED_FOR&&LINUX_NETFILTER
        cfg_directive = "tproxy_uses_indirect_client";
        parse_onoff(&Config.onoff.tproxy_uses_indirect_client);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'tproxy_uses_indirect_client' requires --enable-follow-x-forwarded-for and --enable-linux-netfilter");
#endif
        return 1;
    };
    if (!strcmp(token, "spoof_client_ip")) {
        cfg_directive = "spoof_client_ip";
        parse_acl_access(&Config.accessList.spoof_client_ip);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "http_access")) {
        cfg_directive = "http_access";
        parse_acl_access(&Config.accessList.http);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "adapted_http_access")) {
        cfg_directive = "adapted_http_access";
        parse_acl_access(&Config.accessList.adapted_http);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "http_access2")) {
        cfg_directive = "http_access2";
        parse_acl_access(&Config.accessList.adapted_http);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "http_reply_access")) {
        cfg_directive = "http_reply_access";
        parse_acl_access(&Config.accessList.reply);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "icp_access")) {
        cfg_directive = "icp_access";
        parse_acl_access(&Config.accessList.icp);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "htcp_access")) {
#if USE_HTCP
        cfg_directive = "htcp_access";
        parse_acl_access(&Config.accessList.htcp);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'htcp_access' requires --enable-htcp");
#endif
        return 1;
    };
    if (!strcmp(token, "htcp_clr_access")) {
#if USE_HTCP
        cfg_directive = "htcp_clr_access";
        parse_acl_access(&Config.accessList.htcp_clr);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'htcp_clr_access' requires --enable-htcp");
#endif
        return 1;
    };
    if (!strcmp(token, "miss_access")) {
        cfg_directive = "miss_access";
        parse_acl_access(&Config.accessList.miss);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ident_lookup_access")) {
#if USE_IDENT
        cfg_directive = "ident_lookup_access";
        parse_acl_access(&Ident::TheConfig.identLookup);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'ident_lookup_access' requires --enable-ident-lookups");
#endif
        return 1;
    };
    if (!strcmp(token, "reply_body_max_size")) {
        cfg_directive = "reply_body_max_size";
        parse_acl_b_size_t(&Config.ReplyBodySize);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "http_port")) {
        cfg_directive = "http_port";
        parse_PortCfg(&HttpPortList);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ascii_port")) {
        cfg_directive = "ascii_port";
        parse_PortCfg(&HttpPortList);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "https_port")) {
#if USE_OPENSSL
        cfg_directive = "https_port";
        parse_PortCfg(&HttpsPortList);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'https_port' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "ftp_port")) {
        cfg_directive = "ftp_port";
        parse_PortCfg(&FtpPortList);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "tcp_outgoing_tos")) {
        cfg_directive = "tcp_outgoing_tos";
        parse_acl_tos(&Ip::Qos::TheConfig.tosToServer);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "tcp_outgoing_dscp")) {
        cfg_directive = "tcp_outgoing_dscp";
        parse_acl_tos(&Ip::Qos::TheConfig.tosToServer);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "tcp_outgoing_ds")) {
        cfg_directive = "tcp_outgoing_ds";
        parse_acl_tos(&Ip::Qos::TheConfig.tosToServer);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "clientside_tos")) {
        cfg_directive = "clientside_tos";
        parse_acl_tos(&Ip::Qos::TheConfig.tosToClient);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "tcp_outgoing_mark")) {
#if SO_MARK&&USE_LIBCAP
        cfg_directive = "tcp_outgoing_mark";
        parse_acl_nfmark(&Ip::Qos::TheConfig.nfmarkToServer);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'tcp_outgoing_mark' requires Packet MARK (Linux)");
#endif
        return 1;
    };
    if (!strcmp(token, "clientside_mark")) {
#if SO_MARK&&USE_LIBCAP
        cfg_directive = "clientside_mark";
        parse_acl_nfmark(&Ip::Qos::TheConfig.nfmarkToClient);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'clientside_mark' requires Packet MARK (Linux)");
#endif
        return 1;
    };
    if (!strcmp(token, "qos_flows")) {
#if USE_QOS_TOS
        cfg_directive = "qos_flows";
        parse_QosConfig(&Ip::Qos::TheConfig);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'qos_flows' requires --enable-zph-qos");
#endif
        return 1;
    };
    if (!strcmp(token, "tcp_outgoing_address")) {
        cfg_directive = "tcp_outgoing_address";
        parse_acl_address(&Config.accessList.outgoing_address);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "host_verify_strict")) {
        cfg_directive = "host_verify_strict";
        parse_onoff(&Config.onoff.hostStrictVerify);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "client_dst_passthru")) {
        cfg_directive = "client_dst_passthru";
        parse_onoff(&Config.onoff.client_dst_passthru);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ssl_unclean_shutdown")) {
#if USE_OPENSSL
        cfg_directive = "ssl_unclean_shutdown";
        parse_onoff(&Config.SSL.unclean_shutdown);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'ssl_unclean_shutdown' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "ssl_engine")) {
#if USE_OPENSSL
        cfg_directive = "ssl_engine";
        parse_string(&Config.SSL.ssl_engine);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'ssl_engine' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_client_certificate")) {
#if USE_OPENSSL
        cfg_directive = "sslproxy_client_certificate";
        parse_string(&Config.ssl_client.cert);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_client_certificate' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_client_key")) {
#if USE_OPENSSL
        cfg_directive = "sslproxy_client_key";
        parse_string(&Config.ssl_client.key);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_client_key' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_version")) {
#if USE_OPENSSL
        cfg_directive = "sslproxy_version";
        parse_int(&Config.ssl_client.version);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_version' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_options")) {
#if USE_OPENSSL
        cfg_directive = "sslproxy_options";
        parse_string(&Config.ssl_client.options);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_options' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_cipher")) {
#if USE_OPENSSL
        cfg_directive = "sslproxy_cipher";
        parse_string(&Config.ssl_client.cipher);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_cipher' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_cafile")) {
#if USE_OPENSSL
        cfg_directive = "sslproxy_cafile";
        parse_string(&Config.ssl_client.cafile);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_cafile' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_capath")) {
#if USE_OPENSSL
        cfg_directive = "sslproxy_capath";
        parse_string(&Config.ssl_client.capath);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_capath' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_session_ttl")) {
#if USE_OPENSSL
        cfg_directive = "sslproxy_session_ttl";
        parse_int(&Config.SSL.session_ttl);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_session_ttl' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_session_cache_size")) {
#if USE_OPENSSL
        cfg_directive = "sslproxy_session_cache_size";
        parse_b_size_t(&Config.SSL.sessionCacheSize);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_session_cache_size' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_foreign_intermediate_certs")) {
#if USE_OPENSSL
        cfg_directive = "sslproxy_foreign_intermediate_certs";
        parse_string(&Config.ssl_client.foreignIntermediateCertsPath);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_foreign_intermediate_certs' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_cert_sign_hash")) {
#if USE_OPENSSL
        cfg_directive = "sslproxy_cert_sign_hash";
        parse_string(&Config.SSL.certSignHash);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_cert_sign_hash' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "ssl_bump")) {
#if USE_OPENSSL
        cfg_directive = "ssl_bump";
        parse_sslproxy_ssl_bump(&Config.accessList.ssl_bump);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'ssl_bump' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_flags")) {
#if USE_OPENSSL
        cfg_directive = "sslproxy_flags";
        parse_string(&Config.ssl_client.flags);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_flags' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_cert_error")) {
#if USE_OPENSSL
        cfg_directive = "sslproxy_cert_error";
        parse_acl_access(&Config.ssl_client.cert_error);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_cert_error' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_cert_sign")) {
#if USE_OPENSSL
        cfg_directive = "sslproxy_cert_sign";
        parse_sslproxy_cert_sign(&Config.ssl_client.cert_sign);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_cert_sign' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslproxy_cert_adapt")) {
#if USE_OPENSSL
        cfg_directive = "sslproxy_cert_adapt";
        parse_sslproxy_cert_adapt(&Config.ssl_client.cert_adapt);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslproxy_cert_adapt' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslpassword_program")) {
#if USE_OPENSSL
        cfg_directive = "sslpassword_program";
        parse_string(&Config.Program.ssl_password);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslpassword_program' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslcrtd_program")) {
#if USE_SSL_CRTD
        cfg_directive = "sslcrtd_program";
        parse_eol(&Ssl::TheConfig.ssl_crtd);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslcrtd_program' requires --enable-ssl-crtd");
#endif
        return 1;
    };
    if (!strcmp(token, "sslcrtd_children")) {
#if USE_SSL_CRTD
        cfg_directive = "sslcrtd_children";
        parse_HelperChildConfig(&Ssl::TheConfig.ssl_crtdChildren);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslcrtd_children' requires --enable-ssl-crtd");
#endif
        return 1;
    };
    if (!strcmp(token, "sslcrtvalidator_program")) {
#if USE_OPENSSL
        cfg_directive = "sslcrtvalidator_program";
        parse_eol(&Ssl::TheConfig.ssl_crt_validator);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslcrtvalidator_program' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "sslcrtvalidator_children")) {
#if USE_OPENSSL
        cfg_directive = "sslcrtvalidator_children";
        parse_HelperChildConfig(&Ssl::TheConfig.ssl_crt_validator_Children);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'sslcrtvalidator_children' requires --with-openssl");
#endif
        return 1;
    };
    if (!strcmp(token, "cache_peer")) {
        cfg_directive = "cache_peer";
        parse_peer(&Config.peers);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_peer_domain")) {
        cfg_directive = "cache_peer_domain";
        parse_hostdomain();
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_host_domain")) {
        cfg_directive = "cache_host_domain";
        parse_hostdomain();
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_peer_access")) {
        cfg_directive = "cache_peer_access";
        parse_peer_access();
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "neighbor_type_domain")) {
        cfg_directive = "neighbor_type_domain";
        parse_hostdomaintype();
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "dead_peer_timeout")) {
        cfg_directive = "dead_peer_timeout";
        parse_time_t(&Config.Timeout.deadPeer);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "forward_max_tries")) {
        cfg_directive = "forward_max_tries";
        parse_int(&Config.forward_max_tries);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_mem")) {
        cfg_directive = "cache_mem";
        parse_b_size_t(&Config.memMaxSize);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "maximum_object_size_in_memory")) {
        cfg_directive = "maximum_object_size_in_memory";
        parse_b_size_t(&Config.Store.maxInMemObjSize);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "memory_cache_shared")) {
        cfg_directive = "memory_cache_shared";
        parse_YesNoNone(&Config.memShared);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "memory_cache_mode")) {
        cfg_directive = "memory_cache_mode";
        parse_memcachemode(&Config);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "memory_replacement_policy")) {
        cfg_directive = "memory_replacement_policy";
        parse_removalpolicy(&Config.memPolicy);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_replacement_policy")) {
        cfg_directive = "cache_replacement_policy";
        parse_removalpolicy(&Config.replPolicy);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "minimum_object_size")) {
        cfg_directive = "minimum_object_size";
        parse_b_int64_t(&Config.Store.minObjectSize);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "maximum_object_size")) {
        cfg_directive = "maximum_object_size";
        parse_b_int64_t(&Config.Store.maxObjectSize);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_dir")) {
        cfg_directive = "cache_dir";
        parse_cachedir(&Config.cacheSwap);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "store_dir_select_algorithm")) {
        cfg_directive = "store_dir_select_algorithm";
        parse_string(&Config.store_dir_select_algorithm);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "max_open_disk_fds")) {
        cfg_directive = "max_open_disk_fds";
        parse_int(&Config.max_open_disk_fds);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_swap_low")) {
        cfg_directive = "cache_swap_low";
        parse_int(&Config.Swap.lowWaterMark);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_swap_high")) {
        cfg_directive = "cache_swap_high";
        parse_int(&Config.Swap.highWaterMark);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "logformat")) {
        cfg_directive = "logformat";
        parse_logformat(&Log::TheConfig);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "access_log")) {
        cfg_directive = "access_log";
        parse_access_log(&Config.Log.accesslogs);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_access_log")) {
        cfg_directive = "cache_access_log";
        parse_access_log(&Config.Log.accesslogs);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "icap_log")) {
#if ICAP_CLIENT
        cfg_directive = "icap_log";
        parse_access_log(&Config.Log.icaplogs);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_log' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "logfile_daemon")) {
        cfg_directive = "logfile_daemon";
        parse_string(&Log::TheConfig.logfile_daemon);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "stats_collection")) {
        cfg_directive = "stats_collection";
        parse_acl_access(&Config.accessList.stats_collection);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_store_log")) {
        cfg_directive = "cache_store_log";
        parse_string(&Config.Log.store);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_swap_state")) {
        cfg_directive = "cache_swap_state";
        parse_string(&Config.Log.swap);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_swap_log")) {
        cfg_directive = "cache_swap_log";
        parse_string(&Config.Log.swap);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "logfile_rotate")) {
        cfg_directive = "logfile_rotate";
        parse_int(&Config.Log.rotateNumber);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "mime_table")) {
        cfg_directive = "mime_table";
        parse_string(&Config.mimeTablePathname);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "log_mime_hdrs")) {
        cfg_directive = "log_mime_hdrs";
        parse_onoff(&Config.onoff.log_mime_hdrs);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "pid_filename")) {
        cfg_directive = "pid_filename";
        parse_string(&Config.pidFilename);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "client_netmask")) {
        cfg_directive = "client_netmask";
        parse_address(&Config.Addrs.client_netmask);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "strip_query_terms")) {
        cfg_directive = "strip_query_terms";
        parse_onoff(&Config.onoff.strip_query_terms);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "buffered_logs")) {
        cfg_directive = "buffered_logs";
        parse_onoff(&Config.onoff.buffered_logs);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "netdb_filename")) {
#if USE_ICMP
        cfg_directive = "netdb_filename";
        parse_string(&Config.netdbFilename);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'netdb_filename' requires --enable-icmp");
#endif
        return 1;
    };
    if (!strcmp(token, "cache_log")) {
        cfg_directive = "cache_log";
        parse_string(&Debug::cache_log);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "debug_options")) {
        cfg_directive = "debug_options";
        parse_eol(&Debug::debugOptions);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "coredump_dir")) {
        cfg_directive = "coredump_dir";
        parse_string(&Config.coredump_dir);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ftp_user")) {
        cfg_directive = "ftp_user";
        parse_string(&Config.Ftp.anon_user);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ftp_passive")) {
        cfg_directive = "ftp_passive";
        parse_onoff(&Config.Ftp.passive);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ftp_epsv_all")) {
        cfg_directive = "ftp_epsv_all";
        parse_onoff(&Config.Ftp.epsv_all);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ftp_epsv")) {
        cfg_directive = "ftp_epsv";
        parse_ftp_epsv(&Config.accessList.ftp_epsv);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ftp_eprt")) {
        cfg_directive = "ftp_eprt";
        parse_onoff(&Config.Ftp.eprt);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ftp_sanitycheck")) {
        cfg_directive = "ftp_sanitycheck";
        parse_onoff(&Config.Ftp.sanitycheck);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ftp_telnet_protocol")) {
        cfg_directive = "ftp_telnet_protocol";
        parse_onoff(&Config.Ftp.telnet);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "diskd_program")) {
        cfg_directive = "diskd_program";
        parse_string(&Config.Program.diskd);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "unlinkd_program")) {
#if USE_UNLINKD
        cfg_directive = "unlinkd_program";
        parse_string(&Config.Program.unlinkd);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'unlinkd_program' requires --enable-unlinkd");
#endif
        return 1;
    };
    if (!strcmp(token, "pinger_program")) {
#if USE_ICMP
        cfg_directive = "pinger_program";
        parse_string(&Config.pinger.program);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'pinger_program' requires --enable-icmp");
#endif
        return 1;
    };
    if (!strcmp(token, "pinger_enable")) {
#if USE_ICMP
        cfg_directive = "pinger_enable";
        parse_onoff(&Config.pinger.enable);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'pinger_enable' requires --enable-icmp");
#endif
        return 1;
    };
    if (!strcmp(token, "url_rewrite_program")) {
        cfg_directive = "url_rewrite_program";
        parse_wordlist(&Config.Program.redirect);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "redirect_program")) {
        cfg_directive = "redirect_program";
        parse_wordlist(&Config.Program.redirect);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "url_rewrite_children")) {
        cfg_directive = "url_rewrite_children";
        parse_HelperChildConfig(&Config.redirectChildren);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "redirect_children")) {
        cfg_directive = "redirect_children";
        parse_HelperChildConfig(&Config.redirectChildren);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "url_rewrite_host_header")) {
        cfg_directive = "url_rewrite_host_header";
        parse_onoff(&Config.onoff.redir_rewrites_host);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "redirect_rewrites_host_header")) {
        cfg_directive = "redirect_rewrites_host_header";
        parse_onoff(&Config.onoff.redir_rewrites_host);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "url_rewrite_access")) {
        cfg_directive = "url_rewrite_access";
        parse_acl_access(&Config.accessList.redirector);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "redirector_access")) {
        cfg_directive = "redirector_access";
        parse_acl_access(&Config.accessList.redirector);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "url_rewrite_bypass")) {
        cfg_directive = "url_rewrite_bypass";
        parse_onoff(&Config.onoff.redirector_bypass);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "redirector_bypass")) {
        cfg_directive = "redirector_bypass";
        parse_onoff(&Config.onoff.redirector_bypass);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "url_rewrite_extras")) {
        cfg_directive = "url_rewrite_extras";
        parse_TokenOrQuotedString(&Config.redirector_extras);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "store_id_program")) {
        cfg_directive = "store_id_program";
        parse_wordlist(&Config.Program.store_id);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "storeurl_rewrite_program")) {
        cfg_directive = "storeurl_rewrite_program";
        parse_wordlist(&Config.Program.store_id);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "store_id_extras")) {
        cfg_directive = "store_id_extras";
        parse_TokenOrQuotedString(&Config.storeId_extras);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "store_id_children")) {
        cfg_directive = "store_id_children";
        parse_HelperChildConfig(&Config.storeIdChildren);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "storeurl_rewrite_children")) {
        cfg_directive = "storeurl_rewrite_children";
        parse_HelperChildConfig(&Config.storeIdChildren);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "store_id_access")) {
        cfg_directive = "store_id_access";
        parse_acl_access(&Config.accessList.store_id);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "storeurl_rewrite_access")) {
        cfg_directive = "storeurl_rewrite_access";
        parse_acl_access(&Config.accessList.store_id);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "store_id_bypass")) {
        cfg_directive = "store_id_bypass";
        parse_onoff(&Config.onoff.store_id_bypass);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "storeurl_rewrite_bypass")) {
        cfg_directive = "storeurl_rewrite_bypass";
        parse_onoff(&Config.onoff.store_id_bypass);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache")) {
        cfg_directive = "cache";
        parse_acl_access(&Config.accessList.noCache);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "no_cache")) {
        cfg_directive = "no_cache";
        parse_acl_access(&Config.accessList.noCache);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "send_hit")) {
        cfg_directive = "send_hit";
        parse_acl_access(&Config.accessList.sendHit);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "store_miss")) {
        cfg_directive = "store_miss";
        parse_acl_access(&Config.accessList.storeMiss);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "max_stale")) {
        cfg_directive = "max_stale";
        parse_time_t(&Config.maxStale);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "refresh_pattern")) {
        cfg_directive = "refresh_pattern";
        parse_refreshpattern(&Config.Refresh);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "quick_abort_min")) {
        cfg_directive = "quick_abort_min";
        parse_kb_int64_t(&Config.quickAbort.min);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "quick_abort_max")) {
        cfg_directive = "quick_abort_max";
        parse_kb_int64_t(&Config.quickAbort.max);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "quick_abort_pct")) {
        cfg_directive = "quick_abort_pct";
        parse_int(&Config.quickAbort.pct);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "read_ahead_gap")) {
        cfg_directive = "read_ahead_gap";
        parse_b_int64_t(&Config.readAheadGap);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "negative_ttl")) {
#if USE_HTTP_VIOLATIONS
        cfg_directive = "negative_ttl";
        parse_time_t(&Config.negativeTtl);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'negative_ttl' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "positive_dns_ttl")) {
        cfg_directive = "positive_dns_ttl";
        parse_time_t(&Config.positiveDnsTtl);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "negative_dns_ttl")) {
        cfg_directive = "negative_dns_ttl";
        parse_time_t(&Config.negativeDnsTtl);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "range_offset_limit")) {
        cfg_directive = "range_offset_limit";
        parse_acl_b_size_t(&Config.rangeOffsetLimit);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "minimum_expiry_time")) {
        cfg_directive = "minimum_expiry_time";
        parse_time_t(&Config.minimum_expiry_time);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "store_avg_object_size")) {
        cfg_directive = "store_avg_object_size";
        parse_b_int64_t(&Config.Store.avgObjectSize);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "store_objects_per_bucket")) {
        cfg_directive = "store_objects_per_bucket";
        parse_int(&Config.Store.objectsPerBucket);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "request_header_max_size")) {
        cfg_directive = "request_header_max_size";
        parse_b_size_t(&Config.maxRequestHeaderSize);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "reply_header_max_size")) {
        cfg_directive = "reply_header_max_size";
        parse_b_size_t(&Config.maxReplyHeaderSize);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "request_body_max_size")) {
        cfg_directive = "request_body_max_size";
        parse_b_int64_t(&Config.maxRequestBodySize);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "client_request_buffer_max_size")) {
        cfg_directive = "client_request_buffer_max_size";
        parse_b_size_t(&Config.maxRequestBufferSize);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "broken_posts")) {
#if USE_HTTP_VIOLATIONS
        cfg_directive = "broken_posts";
        parse_acl_access(&Config.accessList.brokenPosts);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'broken_posts' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_uses_indirect_client")) {
#if FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION
        cfg_directive = "adaptation_uses_indirect_client";
        parse_onoff(&Adaptation::Config::use_indirect_client);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_uses_indirect_client' requires --enable-follow-x-forwarded-for and (--enable-icap-client and/or --enable-ecap)");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_uses_indirect_client")) {
#if FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION
        cfg_directive = "icap_uses_indirect_client";
        parse_onoff(&Adaptation::Config::use_indirect_client);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_uses_indirect_client' requires --enable-follow-x-forwarded-for and (--enable-icap-client and/or --enable-ecap)");
#endif
        return 1;
    };
    if (!strcmp(token, "via")) {
#if USE_HTTP_VIOLATIONS
        cfg_directive = "via";
        parse_onoff(&Config.onoff.via);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'via' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "ie_refresh")) {
        cfg_directive = "ie_refresh";
        parse_onoff(&Config.onoff.ie_refresh);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "vary_ignore_expire")) {
        cfg_directive = "vary_ignore_expire";
        parse_onoff(&Config.onoff.vary_ignore_expire);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "request_entities")) {
        cfg_directive = "request_entities";
        parse_onoff(&Config.onoff.request_entities);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "request_header_access")) {
#if USE_HTTP_VIOLATIONS
        cfg_directive = "request_header_access";
        parse_http_header_access(&Config.request_header_access);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'request_header_access' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "reply_header_access")) {
#if USE_HTTP_VIOLATIONS
        cfg_directive = "reply_header_access";
        parse_http_header_access(&Config.reply_header_access);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'reply_header_access' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "request_header_replace")) {
#if USE_HTTP_VIOLATIONS
        cfg_directive = "request_header_replace";
        parse_http_header_replace(&Config.request_header_access);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'request_header_replace' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "header_replace")) {
#if USE_HTTP_VIOLATIONS
        cfg_directive = "header_replace";
        parse_http_header_replace(&Config.request_header_access);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'request_header_replace' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "reply_header_replace")) {
#if USE_HTTP_VIOLATIONS
        cfg_directive = "reply_header_replace";
        parse_http_header_replace(&Config.reply_header_access);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'reply_header_replace' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "request_header_add")) {
        cfg_directive = "request_header_add";
        parse_HeaderWithAclList(&Config.request_header_add);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "note")) {
        cfg_directive = "note";
        parse_note(&Config.notes);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "relaxed_header_parser")) {
        cfg_directive = "relaxed_header_parser";
        parse_tristate(&Config.onoff.relaxed_header_parser);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "collapsed_forwarding")) {
        cfg_directive = "collapsed_forwarding";
        parse_onoff(&Config.onoff.collapsed_forwarding);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "forward_timeout")) {
        cfg_directive = "forward_timeout";
        parse_time_t(&Config.Timeout.forward);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "connect_timeout")) {
        cfg_directive = "connect_timeout";
        parse_time_t(&Config.Timeout.connect);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "peer_connect_timeout")) {
        cfg_directive = "peer_connect_timeout";
        parse_time_t(&Config.Timeout.peer_connect);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "read_timeout")) {
        cfg_directive = "read_timeout";
        parse_time_t(&Config.Timeout.read);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "write_timeout")) {
        cfg_directive = "write_timeout";
        parse_time_t(&Config.Timeout.write);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "request_timeout")) {
        cfg_directive = "request_timeout";
        parse_time_t(&Config.Timeout.request);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "client_idle_pconn_timeout")) {
        cfg_directive = "client_idle_pconn_timeout";
        parse_time_t(&Config.Timeout.clientIdlePconn);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "persistent_request_timeout")) {
        cfg_directive = "persistent_request_timeout";
        parse_time_t(&Config.Timeout.clientIdlePconn);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ftp_client_idle_timeout")) {
        cfg_directive = "ftp_client_idle_timeout";
        parse_time_t(&Config.Timeout.ftpClientIdle);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "client_lifetime")) {
        cfg_directive = "client_lifetime";
        parse_time_t(&Config.Timeout.lifetime);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "half_closed_clients")) {
        cfg_directive = "half_closed_clients";
        parse_onoff(&Config.onoff.half_closed_clients);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "server_idle_pconn_timeout")) {
        cfg_directive = "server_idle_pconn_timeout";
        parse_time_t(&Config.Timeout.serverIdlePconn);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "pconn_timeout")) {
        cfg_directive = "pconn_timeout";
        parse_time_t(&Config.Timeout.serverIdlePconn);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ident_timeout")) {
#if USE_IDENT
        cfg_directive = "ident_timeout";
        parse_time_t(&Ident::TheConfig.timeout);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'ident_timeout' requires --enable-ident-lookups");
#endif
        return 1;
    };
    if (!strcmp(token, "shutdown_lifetime")) {
        cfg_directive = "shutdown_lifetime";
        parse_time_t(&Config.shutdownLifetime);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_mgr")) {
        cfg_directive = "cache_mgr";
        parse_string(&Config.adminEmail);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "mail_from")) {
        cfg_directive = "mail_from";
        parse_string(&Config.EmailFrom);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "mail_program")) {
        cfg_directive = "mail_program";
        parse_eol(&Config.EmailProgram);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_effective_user")) {
        cfg_directive = "cache_effective_user";
        parse_string(&Config.effectiveUser);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_effective_group")) {
        cfg_directive = "cache_effective_group";
        parse_string(&Config.effectiveGroup);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "httpd_suppress_version_string")) {
        cfg_directive = "httpd_suppress_version_string";
        parse_onoff(&Config.onoff.httpd_suppress_version_string);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "visible_hostname")) {
        cfg_directive = "visible_hostname";
        parse_string(&Config.visibleHostname);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "unique_hostname")) {
        cfg_directive = "unique_hostname";
        parse_string(&Config.uniqueHostname);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "hostname_aliases")) {
        cfg_directive = "hostname_aliases";
        parse_wordlist(&Config.hostnameAliases);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "umask")) {
        cfg_directive = "umask";
        parse_int(&Config.umask);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "announce_period")) {
        cfg_directive = "announce_period";
        parse_time_t(&Config.Announce.period);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "announce_host")) {
        cfg_directive = "announce_host";
        parse_string(&Config.Announce.host);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "announce_file")) {
        cfg_directive = "announce_file";
        parse_string(&Config.Announce.file);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "announce_port")) {
        cfg_directive = "announce_port";
        parse_u_short(&Config.Announce.port);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "httpd_accel_surrogate_id")) {
        cfg_directive = "httpd_accel_surrogate_id";
        parse_string(&Config.Accel.surrogate_id);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "http_accel_surrogate_remote")) {
        cfg_directive = "http_accel_surrogate_remote";
        parse_onoff(&Config.onoff.surrogate_is_remote);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "esi_parser")) {
#if USE_SQUID_ESI
        cfg_directive = "esi_parser";
        parse_string(&ESIParser::Type);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'esi_parser' requires --enable-esi");
#endif
        return 1;
    };
    if (!strcmp(token, "delay_pools")) {
#if USE_DELAY_POOLS
        cfg_directive = "delay_pools";
        parse_delay_pool_count(&Config.Delay);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'delay_pools' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "delay_class")) {
#if USE_DELAY_POOLS
        cfg_directive = "delay_class";
        parse_delay_pool_class(&Config.Delay);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'delay_class' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "delay_access")) {
#if USE_DELAY_POOLS
        cfg_directive = "delay_access";
        parse_delay_pool_access(&Config.Delay);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'delay_access' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "delay_parameters")) {
#if USE_DELAY_POOLS
        cfg_directive = "delay_parameters";
        parse_delay_pool_rates(&Config.Delay);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'delay_parameters' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "delay_initial_bucket_level")) {
#if USE_DELAY_POOLS
        cfg_directive = "delay_initial_bucket_level";
        parse_u_short(&Config.Delay.initial);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'delay_initial_bucket_level' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "client_delay_pools")) {
#if USE_DELAY_POOLS
        cfg_directive = "client_delay_pools";
        parse_client_delay_pool_count(&Config.ClientDelay);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'client_delay_pools' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "client_delay_initial_bucket_level")) {
#if USE_DELAY_POOLS
        cfg_directive = "client_delay_initial_bucket_level";
        parse_u_short(&Config.ClientDelay.initial);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'client_delay_initial_bucket_level' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "client_delay_parameters")) {
#if USE_DELAY_POOLS
        cfg_directive = "client_delay_parameters";
        parse_client_delay_pool_rates(&Config.ClientDelay);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'client_delay_parameters' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "client_delay_access")) {
#if USE_DELAY_POOLS
        cfg_directive = "client_delay_access";
        parse_client_delay_pool_access(&Config.ClientDelay);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'client_delay_access' requires --enable-delay-pools");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp_router")) {
#if USE_WCCP
        cfg_directive = "wccp_router";
        parse_address(&Config.Wccp.router);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp_router' requires --enable-wccp");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_router")) {
#if USE_WCCPv2
        cfg_directive = "wccp2_router";
        parse_IpAddress_list(&Config.Wccp2.router);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_router' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp_version")) {
#if USE_WCCP
        cfg_directive = "wccp_version";
        parse_int(&Config.Wccp.version);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp_version' requires --enable-wccp");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_rebuild_wait")) {
#if USE_WCCPv2
        cfg_directive = "wccp2_rebuild_wait";
        parse_onoff(&Config.Wccp2.rebuildwait);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_rebuild_wait' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_forwarding_method")) {
#if USE_WCCPv2
        cfg_directive = "wccp2_forwarding_method";
        parse_wccp2_method(&Config.Wccp2.forwarding_method);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_forwarding_method' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_return_method")) {
#if USE_WCCPv2
        cfg_directive = "wccp2_return_method";
        parse_wccp2_method(&Config.Wccp2.return_method);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_return_method' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_assignment_method")) {
#if USE_WCCPv2
        cfg_directive = "wccp2_assignment_method";
        parse_wccp2_amethod(&Config.Wccp2.assignment_method);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_assignment_method' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_service")) {
#if USE_WCCPv2
        cfg_directive = "wccp2_service";
        parse_wccp2_service(&Config.Wccp2.info);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_service' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_service_info")) {
#if USE_WCCPv2
        cfg_directive = "wccp2_service_info";
        parse_wccp2_service_info(&Config.Wccp2.info);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_service_info' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_weight")) {
#if USE_WCCPv2
        cfg_directive = "wccp2_weight";
        parse_int(&Config.Wccp2.weight);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_weight' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp_address")) {
#if USE_WCCP
        cfg_directive = "wccp_address";
        parse_address(&Config.Wccp.address);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp_address' requires --enable-wccp");
#endif
        return 1;
    };
    if (!strcmp(token, "wccp2_address")) {
#if USE_WCCPv2
        cfg_directive = "wccp2_address";
        parse_address(&Config.Wccp2.address);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'wccp2_address' requires --enable-wccpv2");
#endif
        return 1;
    };
    if (!strcmp(token, "client_persistent_connections")) {
        cfg_directive = "client_persistent_connections";
        parse_onoff(&Config.onoff.client_pconns);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "server_persistent_connections")) {
        cfg_directive = "server_persistent_connections";
        parse_onoff(&Config.onoff.server_pconns);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "persistent_connection_after_error")) {
        cfg_directive = "persistent_connection_after_error";
        parse_onoff(&Config.onoff.error_pconns);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "detect_broken_pconn")) {
        cfg_directive = "detect_broken_pconn";
        parse_onoff(&Config.onoff.detect_broken_server_pconns);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "digest_generation")) {
#if USE_CACHE_DIGESTS
        cfg_directive = "digest_generation";
        parse_onoff(&Config.onoff.digest_generation);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'digest_generation' requires --enable-cache-digests");
#endif
        return 1;
    };
    if (!strcmp(token, "digest_bits_per_entry")) {
#if USE_CACHE_DIGESTS
        cfg_directive = "digest_bits_per_entry";
        parse_int(&Config.digest.bits_per_entry);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'digest_bits_per_entry' requires --enable-cache-digests");
#endif
        return 1;
    };
    if (!strcmp(token, "digest_rebuild_period")) {
#if USE_CACHE_DIGESTS
        cfg_directive = "digest_rebuild_period";
        parse_time_t(&Config.digest.rebuild_period);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'digest_rebuild_period' requires --enable-cache-digests");
#endif
        return 1;
    };
    if (!strcmp(token, "digest_rewrite_period")) {
#if USE_CACHE_DIGESTS
        cfg_directive = "digest_rewrite_period";
        parse_time_t(&Config.digest.rewrite_period);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'digest_rewrite_period' requires --enable-cache-digests");
#endif
        return 1;
    };
    if (!strcmp(token, "digest_swapout_chunk_size")) {
#if USE_CACHE_DIGESTS
        cfg_directive = "digest_swapout_chunk_size";
        parse_b_size_t(&Config.digest.swapout_chunk_size);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'digest_swapout_chunk_size' requires --enable-cache-digests");
#endif
        return 1;
    };
    if (!strcmp(token, "digest_rebuild_chunk_percentage")) {
#if USE_CACHE_DIGESTS
        cfg_directive = "digest_rebuild_chunk_percentage";
        parse_int(&Config.digest.rebuild_chunk_percentage);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'digest_rebuild_chunk_percentage' requires --enable-cache-digests");
#endif
        return 1;
    };
    if (!strcmp(token, "snmp_port")) {
#if SQUID_SNMP
        cfg_directive = "snmp_port";
        parse_u_short(&Config.Port.snmp);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'snmp_port' requires --enable-snmp");
#endif
        return 1;
    };
    if (!strcmp(token, "snmp_access")) {
#if SQUID_SNMP
        cfg_directive = "snmp_access";
        parse_acl_access(&Config.accessList.snmp);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'snmp_access' requires --enable-snmp");
#endif
        return 1;
    };
    if (!strcmp(token, "snmp_incoming_address")) {
#if SQUID_SNMP
        cfg_directive = "snmp_incoming_address";
        parse_address(&Config.Addrs.snmp_incoming);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'snmp_incoming_address' requires --enable-snmp");
#endif
        return 1;
    };
    if (!strcmp(token, "snmp_outgoing_address")) {
#if SQUID_SNMP
        cfg_directive = "snmp_outgoing_address";
        parse_address(&Config.Addrs.snmp_outgoing);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'snmp_outgoing_address' requires --enable-snmp");
#endif
        return 1;
    };
    if (!strcmp(token, "icp_port")) {
        cfg_directive = "icp_port";
        parse_u_short(&Config.Port.icp);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "udp_port")) {
        cfg_directive = "udp_port";
        parse_u_short(&Config.Port.icp);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "htcp_port")) {
#if USE_HTCP
        cfg_directive = "htcp_port";
        parse_u_short(&Config.Port.htcp);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'htcp_port' requires --enable-htcp");
#endif
        return 1;
    };
    if (!strcmp(token, "log_icp_queries")) {
        cfg_directive = "log_icp_queries";
        parse_onoff(&Config.onoff.log_udp);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "udp_incoming_address")) {
        cfg_directive = "udp_incoming_address";
        parse_address(&Config.Addrs.udp_incoming);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "udp_outgoing_address")) {
        cfg_directive = "udp_outgoing_address";
        parse_address(&Config.Addrs.udp_outgoing);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "icp_hit_stale")) {
        cfg_directive = "icp_hit_stale";
        parse_onoff(&Config.onoff.icp_hit_stale);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "minimum_direct_hops")) {
        cfg_directive = "minimum_direct_hops";
        parse_int(&Config.minDirectHops);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "minimum_direct_rtt")) {
        cfg_directive = "minimum_direct_rtt";
        parse_int(&Config.minDirectRtt);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "netdb_low")) {
        cfg_directive = "netdb_low";
        parse_int(&Config.Netdb.low);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "netdb_high")) {
        cfg_directive = "netdb_high";
        parse_int(&Config.Netdb.high);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "netdb_ping_period")) {
        cfg_directive = "netdb_ping_period";
        parse_time_t(&Config.Netdb.period);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "query_icmp")) {
        cfg_directive = "query_icmp";
        parse_onoff(&Config.onoff.query_icmp);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "test_reachability")) {
        cfg_directive = "test_reachability";
        parse_onoff(&Config.onoff.test_reachability);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "icp_query_timeout")) {
        cfg_directive = "icp_query_timeout";
        parse_int(&Config.Timeout.icp_query);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "maximum_icp_query_timeout")) {
        cfg_directive = "maximum_icp_query_timeout";
        parse_int(&Config.Timeout.icp_query_max);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "minimum_icp_query_timeout")) {
        cfg_directive = "minimum_icp_query_timeout";
        parse_int(&Config.Timeout.icp_query_min);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "background_ping_rate")) {
        cfg_directive = "background_ping_rate";
        parse_time_t(&Config.backgroundPingRate);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "mcast_groups")) {
        cfg_directive = "mcast_groups";
        parse_wordlist(&Config.mcast_group_list);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "mcast_miss_addr")) {
#if MULTICAST_MISS_STREAM
        cfg_directive = "mcast_miss_addr";
        parse_address(&Config.mcast_miss.addr);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'mcast_miss_addr' requires -DMULTICAST_MISS_STREAM define");
#endif
        return 1;
    };
    if (!strcmp(token, "mcast_miss_ttl")) {
#if MULTICAST_MISS_STREAM
        cfg_directive = "mcast_miss_ttl";
        parse_u_short(&Config.mcast_miss.ttl);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'mcast_miss_ttl' requires -DMULTICAST_MISS_STREAM define");
#endif
        return 1;
    };
    if (!strcmp(token, "mcast_miss_port")) {
#if MULTICAST_MISS_STREAM
        cfg_directive = "mcast_miss_port";
        parse_u_short(&Config.mcast_miss.port);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'mcast_miss_port' requires -DMULTICAST_MISS_STREAM define");
#endif
        return 1;
    };
    if (!strcmp(token, "mcast_miss_encode_key")) {
#if MULTICAST_MISS_STREAM
        cfg_directive = "mcast_miss_encode_key";
        parse_string(&Config.mcast_miss.encode_key);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'mcast_miss_encode_key' requires -DMULTICAST_MISS_STREAM define");
#endif
        return 1;
    };
    if (!strcmp(token, "mcast_icp_query_timeout")) {
        cfg_directive = "mcast_icp_query_timeout";
        parse_int(&Config.Timeout.mcast_icp_query);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "icon_directory")) {
        cfg_directive = "icon_directory";
        parse_string(&Config.icons.directory);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "global_internal_static")) {
        cfg_directive = "global_internal_static";
        parse_onoff(&Config.onoff.global_internal_static);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "short_icon_urls")) {
        cfg_directive = "short_icon_urls";
        parse_onoff(&Config.icons.use_short_names);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "error_directory")) {
        cfg_directive = "error_directory";
        parse_string(&Config.errorDirectory);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "error_default_language")) {
#if USE_ERR_LOCALES
        cfg_directive = "error_default_language";
        parse_string(&Config.errorDefaultLanguage);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'error_default_language' requires --enable-auto-locale");
#endif
        return 1;
    };
    if (!strcmp(token, "error_log_languages")) {
#if USE_ERR_LOCALES
        cfg_directive = "error_log_languages";
        parse_onoff(&Config.errorLogMissingLanguages);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'error_log_languages' requires --enable-auto-locale");
#endif
        return 1;
    };
    if (!strcmp(token, "err_page_stylesheet")) {
        cfg_directive = "err_page_stylesheet";
        parse_string(&Config.errorStylesheet);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "err_html_text")) {
        cfg_directive = "err_html_text";
        parse_eol(&Config.errHtmlText);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "email_err_data")) {
        cfg_directive = "email_err_data";
        parse_onoff(&Config.onoff.emailErrData);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "deny_info")) {
        cfg_directive = "deny_info";
        parse_denyinfo(&Config.denyInfoList);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "nonhierarchical_direct")) {
        cfg_directive = "nonhierarchical_direct";
        parse_onoff(&Config.onoff.nonhierarchical_direct);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "prefer_direct")) {
        cfg_directive = "prefer_direct";
        parse_onoff(&Config.onoff.prefer_direct);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cache_miss_revalidate")) {
        cfg_directive = "cache_miss_revalidate";
        parse_onoff(&Config.onoff.cache_miss_revalidate);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "always_direct")) {
        cfg_directive = "always_direct";
        parse_acl_access(&Config.accessList.AlwaysDirect);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "never_direct")) {
        cfg_directive = "never_direct";
        parse_acl_access(&Config.accessList.NeverDirect);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "incoming_udp_average")) {
        cfg_directive = "incoming_udp_average";
        parse_int(&Config.comm_incoming.udp.average);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "incoming_icp_average")) {
        cfg_directive = "incoming_icp_average";
        parse_int(&Config.comm_incoming.udp.average);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "incoming_tcp_average")) {
        cfg_directive = "incoming_tcp_average";
        parse_int(&Config.comm_incoming.tcp.average);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "incoming_http_average")) {
        cfg_directive = "incoming_http_average";
        parse_int(&Config.comm_incoming.tcp.average);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "incoming_dns_average")) {
        cfg_directive = "incoming_dns_average";
        parse_int(&Config.comm_incoming.dns.average);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "min_udp_poll_cnt")) {
        cfg_directive = "min_udp_poll_cnt";
        parse_int(&Config.comm_incoming.udp.min_poll);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "min_icp_poll_cnt")) {
        cfg_directive = "min_icp_poll_cnt";
        parse_int(&Config.comm_incoming.udp.min_poll);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "min_dns_poll_cnt")) {
        cfg_directive = "min_dns_poll_cnt";
        parse_int(&Config.comm_incoming.dns.min_poll);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "min_tcp_poll_cnt")) {
        cfg_directive = "min_tcp_poll_cnt";
        parse_int(&Config.comm_incoming.tcp.min_poll);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "min_http_poll_cnt")) {
        cfg_directive = "min_http_poll_cnt";
        parse_int(&Config.comm_incoming.tcp.min_poll);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "accept_filter")) {
        cfg_directive = "accept_filter";
        parse_string(&Config.accept_filter);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "client_ip_max_connections")) {
        cfg_directive = "client_ip_max_connections";
        parse_int(&Config.client_ip_max_connections);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "tcp_recv_bufsize")) {
        cfg_directive = "tcp_recv_bufsize";
        parse_b_size_t(&Config.tcpRcvBufsz);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "icap_enable")) {
#if ICAP_CLIENT
        cfg_directive = "icap_enable";
        parse_onoff(&Adaptation::Icap::TheConfig.onoff);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_enable' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_connect_timeout")) {
#if ICAP_CLIENT
        cfg_directive = "icap_connect_timeout";
        parse_time_t(&Adaptation::Icap::TheConfig.connect_timeout_raw);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_connect_timeout' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_io_timeout")) {
#if ICAP_CLIENT
        cfg_directive = "icap_io_timeout";
        parse_time_t(&Adaptation::Icap::TheConfig.io_timeout_raw);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_io_timeout' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_service_failure_limit")) {
#if ICAP_CLIENT
        cfg_directive = "icap_service_failure_limit";
        parse_icap_service_failure_limit(&Adaptation::Icap::TheConfig);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_service_failure_limit' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_service_revival_delay")) {
#if ICAP_CLIENT
        cfg_directive = "icap_service_revival_delay";
        parse_int(&Adaptation::Icap::TheConfig.service_revival_delay);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_service_revival_delay' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_preview_enable")) {
#if ICAP_CLIENT
        cfg_directive = "icap_preview_enable";
        parse_onoff(&Adaptation::Icap::TheConfig.preview_enable);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_preview_enable' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_preview_size")) {
#if ICAP_CLIENT
        cfg_directive = "icap_preview_size";
        parse_int(&Adaptation::Icap::TheConfig.preview_size);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_preview_size' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_206_enable")) {
#if ICAP_CLIENT
        cfg_directive = "icap_206_enable";
        parse_onoff(&Adaptation::Icap::TheConfig.allow206_enable);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_206_enable' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_default_options_ttl")) {
#if ICAP_CLIENT
        cfg_directive = "icap_default_options_ttl";
        parse_int(&Adaptation::Icap::TheConfig.default_options_ttl);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_default_options_ttl' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_persistent_connections")) {
#if ICAP_CLIENT
        cfg_directive = "icap_persistent_connections";
        parse_onoff(&Adaptation::Icap::TheConfig.reuse_connections);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_persistent_connections' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_send_client_ip")) {
#if USE_ADAPTATION
        cfg_directive = "adaptation_send_client_ip";
        parse_onoff(&Adaptation::Config::send_client_ip);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_send_client_ip' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_send_client_ip")) {
#if USE_ADAPTATION
        cfg_directive = "icap_send_client_ip";
        parse_onoff(&Adaptation::Config::send_client_ip);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_send_client_ip' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_send_username")) {
#if USE_ADAPTATION
        cfg_directive = "adaptation_send_username";
        parse_onoff(&Adaptation::Config::send_username);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_send_username' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_send_client_username")) {
#if USE_ADAPTATION
        cfg_directive = "icap_send_client_username";
        parse_onoff(&Adaptation::Config::send_username);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_send_username' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_client_username_header")) {
#if ICAP_CLIENT
        cfg_directive = "icap_client_username_header";
        parse_string(&Adaptation::Icap::TheConfig.client_username_header);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_client_username_header' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_client_username_encode")) {
#if ICAP_CLIENT
        cfg_directive = "icap_client_username_encode";
        parse_onoff(&Adaptation::Icap::TheConfig.client_username_encode);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_client_username_encode' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_service")) {
#if ICAP_CLIENT
        cfg_directive = "icap_service";
        parse_icap_service_type(&Adaptation::Icap::TheConfig);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_service' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_class")) {
#if ICAP_CLIENT
        cfg_directive = "icap_class";
        parse_icap_class_type();
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_class' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_access")) {
#if ICAP_CLIENT
        cfg_directive = "icap_access";
        parse_icap_access_type();
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_access' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "ecap_enable")) {
#if USE_ECAP
        cfg_directive = "ecap_enable";
        parse_onoff(&Adaptation::Ecap::TheConfig.onoff);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'ecap_enable' requires --enable-ecap");
#endif
        return 1;
    };
    if (!strcmp(token, "ecap_service")) {
#if USE_ECAP
        cfg_directive = "ecap_service";
        parse_ecap_service_type(&Adaptation::Ecap::TheConfig);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'ecap_service' requires --enable-ecap");
#endif
        return 1;
    };
    if (!strcmp(token, "loadable_modules")) {
#if USE_LOADABLE_MODULES
        cfg_directive = "loadable_modules";
        parse_wordlist(&Config.loadable_module_names);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'loadable_modules' requires --enable-loadable-modules");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_service_set")) {
#if USE_ADAPTATION
        cfg_directive = "adaptation_service_set";
        parse_adaptation_service_set_type();
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_service_set' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_service_chain")) {
#if USE_ADAPTATION
        cfg_directive = "adaptation_service_chain";
        parse_adaptation_service_chain_type();
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_service_chain' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_access")) {
#if USE_ADAPTATION
        cfg_directive = "adaptation_access";
        parse_adaptation_access_type();
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_access' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_service_iteration_limit")) {
#if USE_ADAPTATION
        cfg_directive = "adaptation_service_iteration_limit";
        parse_int(&Adaptation::Config::service_iteration_limit);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_service_iteration_limit' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_masterx_shared_names")) {
#if USE_ADAPTATION
        cfg_directive = "adaptation_masterx_shared_names";
        parse_string(&Adaptation::Config::masterx_shared_name);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_masterx_shared_names' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "adaptation_meta")) {
#if USE_ADAPTATION
        cfg_directive = "adaptation_meta";
        parse_note(&Adaptation::Config::metaHeaders);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'adaptation_meta' requires --enable-ecap or --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_retry")) {
#if ICAP_CLIENT
        cfg_directive = "icap_retry";
        parse_acl_access(&Adaptation::Icap::TheConfig.repeat);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_retry' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "icap_retry_limit")) {
#if ICAP_CLIENT
        cfg_directive = "icap_retry_limit";
        parse_int(&Adaptation::Icap::TheConfig.repeat_limit);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'icap_retry_limit' requires --enable-icap-client");
#endif
        return 1;
    };
    if (!strcmp(token, "check_hostnames")) {
        cfg_directive = "check_hostnames";
        parse_onoff(&Config.onoff.check_hostnames);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "allow_underscore")) {
        cfg_directive = "allow_underscore";
        parse_onoff(&Config.onoff.allow_underscore);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "dns_retransmit_interval")) {
        cfg_directive = "dns_retransmit_interval";
        parse_time_msec(&Config.Timeout.idns_retransmit);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "dns_timeout")) {
        cfg_directive = "dns_timeout";
        parse_time_msec(&Config.Timeout.idns_query);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "dns_packet_max")) {
        cfg_directive = "dns_packet_max";
        parse_b_ssize_t(&Config.dns.packet_max);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "dns_defnames")) {
        cfg_directive = "dns_defnames";
        parse_onoff(&Config.onoff.res_defnames);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "dns_multicast_local")) {
        cfg_directive = "dns_multicast_local";
        parse_onoff(&Config.onoff.dns_mdns);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "dns_nameservers")) {
        cfg_directive = "dns_nameservers";
        parse_wordlist(&Config.dns_nameservers);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "hosts_file")) {
        cfg_directive = "hosts_file";
        parse_string(&Config.etcHostsPath);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "append_domain")) {
        cfg_directive = "append_domain";
        parse_string(&Config.appendDomain);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ignore_unknown_nameservers")) {
        cfg_directive = "ignore_unknown_nameservers";
        parse_onoff(&Config.onoff.ignore_unknown_nameservers);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "dns_v4_first")) {
        cfg_directive = "dns_v4_first";
        parse_onoff(&Config.dns.v4_first);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ipcache_size")) {
        cfg_directive = "ipcache_size";
        parse_int(&Config.ipcache.size);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ipcache_low")) {
        cfg_directive = "ipcache_low";
        parse_int(&Config.ipcache.low);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "ipcache_high")) {
        cfg_directive = "ipcache_high";
        parse_int(&Config.ipcache.high);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "fqdncache_size")) {
        cfg_directive = "fqdncache_size";
        parse_int(&Config.fqdncache.size);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "configuration_includes_quoted_values")) {
        cfg_directive = "configuration_includes_quoted_values";
        parse_configuration_includes_quoted_values(&ConfigParser::RecognizeQuotedValues);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "memory_pools")) {
        cfg_directive = "memory_pools";
        parse_onoff(&Config.onoff.mem_pools);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "memory_pools_limit")) {
        cfg_directive = "memory_pools_limit";
        parse_b_int64_t(&Config.MemPools.limit);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "forwarded_for")) {
        cfg_directive = "forwarded_for";
        parse_string(&opt_forwarded_for);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "cachemgr_passwd")) {
        cfg_directive = "cachemgr_passwd";
        parse_cachemgrpasswd(&Config.passwd_list);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "client_db")) {
        cfg_directive = "client_db";
        parse_onoff(&Config.onoff.client_db);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "refresh_all_ims")) {
        cfg_directive = "refresh_all_ims";
        parse_onoff(&Config.onoff.refresh_all_ims);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "reload_into_ims")) {
#if USE_HTTP_VIOLATIONS
        cfg_directive = "reload_into_ims";
        parse_onoff(&Config.onoff.reload_into_ims);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'reload_into_ims' requires --enable-http-violations");
#endif
        return 1;
    };
    if (!strcmp(token, "connect_retries")) {
        cfg_directive = "connect_retries";
        parse_int(&Config.connect_retries);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "retry_on_error")) {
        cfg_directive = "retry_on_error";
        parse_onoff(&Config.retry.onerror);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "as_whois_server")) {
        cfg_directive = "as_whois_server";
        parse_string(&Config.as_whois_server);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "offline_mode")) {
        cfg_directive = "offline_mode";
        parse_onoff(&Config.onoff.offline);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "uri_whitespace")) {
        cfg_directive = "uri_whitespace";
        parse_uri_whitespace(&Config.uri_whitespace);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "chroot")) {
        cfg_directive = "chroot";
        parse_string(&Config.chroot_dir);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "balance_on_multiple_ip")) {
        cfg_directive = "balance_on_multiple_ip";
        parse_onoff(&Config.onoff.balance_on_multiple_ip);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "pipeline_prefetch")) {
        cfg_directive = "pipeline_prefetch";
        parse_pipelinePrefetch(&Config.pipeline_max_prefetch);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "high_response_time_warning")) {
        cfg_directive = "high_response_time_warning";
        parse_int(&Config.warnings.high_rptm);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "high_page_fault_warning")) {
        cfg_directive = "high_page_fault_warning";
        parse_int(&Config.warnings.high_pf);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "high_memory_warning")) {
#if HAVE_MSTATS&&HAVE_GNUMALLOC_H
        cfg_directive = "high_memory_warning";
        parse_b_size_t(&Config.warnings.high_memory);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'high_memory_warning' requires GNU Malloc with mstats()");
#endif
        return 1;
    };
    if (!strcmp(token, "sleep_after_fork")) {
        cfg_directive = "sleep_after_fork";
        parse_int(&Config.sleep_after_fork);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "windows_ipaddrchangemonitor")) {
#if _SQUID_WINDOWS_
        cfg_directive = "windows_ipaddrchangemonitor";
        parse_onoff(&Config.onoff.WIN32_IpAddrChangeMonitor);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'windows_ipaddrchangemonitor' requires MS Windows");
#endif
        return 1;
    };
    if (!strcmp(token, "eui_lookup")) {
#if USE_SQUID_EUI
        cfg_directive = "eui_lookup";
        parse_onoff(&Eui::TheConfig.euiLookup);
        cfg_directive = NULL;
#else
    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: 'eui_lookup' requires --enable-eui");
#endif
        return 1;
    };
    if (!strcmp(token, "max_filedescriptors")) {
        cfg_directive = "max_filedescriptors";
        parse_int(&Config.max_filedescriptors);
        cfg_directive = NULL;
        return 1;
    };
    if (!strcmp(token, "max_filedesc")) {
        cfg_directive = "max_filedesc";
        parse_int(&Config.max_filedescriptors);
        cfg_directive = NULL;
        return 1;
    };
	return 0; /* failure */
}

static void
dump_config(StoreEntry *entry)
{
    debugs(5, 4, HERE);
    dump_int(entry, "workers", Config.workers);
    dump_CpuAffinityMap(entry, "cpu_affinity_map", Config.cpuAffinityMap);
#if USE_AUTH
    dump_authparam(entry, "auth_param", Auth::TheConfig);
#endif
    dump_time_t(entry, "authenticate_cache_garbage_interval", Config.authenticateGCInterval);
    dump_time_t(entry, "authenticate_ttl", Config.authenticateTTL);
    dump_time_t(entry, "authenticate_ip_ttl", Config.authenticateIpTTL);
    dump_externalAclHelper(entry, "external_acl_type", Config.externalAclHelperList);
    dump_acl(entry, "acl", Config.aclList);
    dump_acl_access(entry, "proxy_protocol_access", Config.accessList.proxyProtocol);
#if FOLLOW_X_FORWARDED_FOR
    dump_acl_access(entry, "follow_x_forwarded_for", Config.accessList.followXFF);
#endif
#if FOLLOW_X_FORWARDED_FOR
    dump_onoff(entry, "acl_uses_indirect_client", Config.onoff.acl_uses_indirect_client);
#endif
#if FOLLOW_X_FORWARDED_FOR&&USE_DELAY_POOLS
    dump_onoff(entry, "delay_pool_uses_indirect_client", Config.onoff.delay_pool_uses_indirect_client);
#endif
#if FOLLOW_X_FORWARDED_FOR
    dump_onoff(entry, "log_uses_indirect_client", Config.onoff.log_uses_indirect_client);
#endif
#if FOLLOW_X_FORWARDED_FOR&&LINUX_NETFILTER
    dump_onoff(entry, "tproxy_uses_indirect_client", Config.onoff.tproxy_uses_indirect_client);
#endif
    dump_acl_access(entry, "spoof_client_ip", Config.accessList.spoof_client_ip);
    dump_acl_access(entry, "http_access", Config.accessList.http);
    dump_acl_access(entry, "adapted_http_access", Config.accessList.adapted_http);
    dump_acl_access(entry, "http_reply_access", Config.accessList.reply);
    dump_acl_access(entry, "icp_access", Config.accessList.icp);
#if USE_HTCP
    dump_acl_access(entry, "htcp_access", Config.accessList.htcp);
#endif
#if USE_HTCP
    dump_acl_access(entry, "htcp_clr_access", Config.accessList.htcp_clr);
#endif
    dump_acl_access(entry, "miss_access", Config.accessList.miss);
#if USE_IDENT
    dump_acl_access(entry, "ident_lookup_access", Ident::TheConfig.identLookup);
#endif
    dump_acl_b_size_t(entry, "reply_body_max_size", Config.ReplyBodySize);
    dump_PortCfg(entry, "http_port", HttpPortList);
#if USE_OPENSSL
    dump_PortCfg(entry, "https_port", HttpsPortList);
#endif
    dump_PortCfg(entry, "ftp_port", FtpPortList);
    dump_acl_tos(entry, "tcp_outgoing_tos", Ip::Qos::TheConfig.tosToServer);
    dump_acl_tos(entry, "clientside_tos", Ip::Qos::TheConfig.tosToClient);
#if SO_MARK&&USE_LIBCAP
    dump_acl_nfmark(entry, "tcp_outgoing_mark", Ip::Qos::TheConfig.nfmarkToServer);
#endif
#if SO_MARK&&USE_LIBCAP
    dump_acl_nfmark(entry, "clientside_mark", Ip::Qos::TheConfig.nfmarkToClient);
#endif
#if USE_QOS_TOS
    dump_QosConfig(entry, "qos_flows", Ip::Qos::TheConfig);
#endif
    dump_acl_address(entry, "tcp_outgoing_address", Config.accessList.outgoing_address);
    dump_onoff(entry, "host_verify_strict", Config.onoff.hostStrictVerify);
    dump_onoff(entry, "client_dst_passthru", Config.onoff.client_dst_passthru);
#if USE_OPENSSL
    dump_onoff(entry, "ssl_unclean_shutdown", Config.SSL.unclean_shutdown);
#endif
#if USE_OPENSSL
    dump_string(entry, "ssl_engine", Config.SSL.ssl_engine);
#endif
#if USE_OPENSSL
    dump_string(entry, "sslproxy_client_certificate", Config.ssl_client.cert);
#endif
#if USE_OPENSSL
    dump_string(entry, "sslproxy_client_key", Config.ssl_client.key);
#endif
#if USE_OPENSSL
    dump_int(entry, "sslproxy_version", Config.ssl_client.version);
#endif
#if USE_OPENSSL
    dump_string(entry, "sslproxy_options", Config.ssl_client.options);
#endif
#if USE_OPENSSL
    dump_string(entry, "sslproxy_cipher", Config.ssl_client.cipher);
#endif
#if USE_OPENSSL
    dump_string(entry, "sslproxy_cafile", Config.ssl_client.cafile);
#endif
#if USE_OPENSSL
    dump_string(entry, "sslproxy_capath", Config.ssl_client.capath);
#endif
#if USE_OPENSSL
    dump_int(entry, "sslproxy_session_ttl", Config.SSL.session_ttl);
#endif
#if USE_OPENSSL
    dump_b_size_t(entry, "sslproxy_session_cache_size", Config.SSL.sessionCacheSize);
#endif
#if USE_OPENSSL
    dump_string(entry, "sslproxy_foreign_intermediate_certs", Config.ssl_client.foreignIntermediateCertsPath);
#endif
#if USE_OPENSSL
    dump_string(entry, "sslproxy_cert_sign_hash", Config.SSL.certSignHash);
#endif
#if USE_OPENSSL
    dump_sslproxy_ssl_bump(entry, "ssl_bump", Config.accessList.ssl_bump);
#endif
#if USE_OPENSSL
    dump_string(entry, "sslproxy_flags", Config.ssl_client.flags);
#endif
#if USE_OPENSSL
    dump_acl_access(entry, "sslproxy_cert_error", Config.ssl_client.cert_error);
#endif
#if USE_OPENSSL
    dump_sslproxy_cert_sign(entry, "sslproxy_cert_sign", Config.ssl_client.cert_sign);
#endif
#if USE_OPENSSL
    dump_sslproxy_cert_adapt(entry, "sslproxy_cert_adapt", Config.ssl_client.cert_adapt);
#endif
#if USE_OPENSSL
    dump_string(entry, "sslpassword_program", Config.Program.ssl_password);
#endif
#if USE_SSL_CRTD
    dump_eol(entry, "sslcrtd_program", Ssl::TheConfig.ssl_crtd);
#endif
#if USE_SSL_CRTD
    dump_HelperChildConfig(entry, "sslcrtd_children", Ssl::TheConfig.ssl_crtdChildren);
#endif
#if USE_OPENSSL
    dump_eol(entry, "sslcrtvalidator_program", Ssl::TheConfig.ssl_crt_validator);
#endif
#if USE_OPENSSL
    dump_HelperChildConfig(entry, "sslcrtvalidator_children", Ssl::TheConfig.ssl_crt_validator_Children);
#endif
    dump_peer(entry, "cache_peer", Config.peers);
    dump_time_t(entry, "dead_peer_timeout", Config.Timeout.deadPeer);
    dump_int(entry, "forward_max_tries", Config.forward_max_tries);
    dump_b_size_t(entry, "cache_mem", Config.memMaxSize);
    dump_b_size_t(entry, "maximum_object_size_in_memory", Config.Store.maxInMemObjSize);
    dump_YesNoNone(entry, "memory_cache_shared", Config.memShared);
    dump_memcachemode(entry, "memory_cache_mode", Config);
    dump_removalpolicy(entry, "memory_replacement_policy", Config.memPolicy);
    dump_removalpolicy(entry, "cache_replacement_policy", Config.replPolicy);
    dump_b_int64_t(entry, "minimum_object_size", Config.Store.minObjectSize);
    dump_b_int64_t(entry, "maximum_object_size", Config.Store.maxObjectSize);
    dump_cachedir(entry, "cache_dir", Config.cacheSwap);
    dump_string(entry, "store_dir_select_algorithm", Config.store_dir_select_algorithm);
    dump_int(entry, "max_open_disk_fds", Config.max_open_disk_fds);
    dump_int(entry, "cache_swap_low", Config.Swap.lowWaterMark);
    dump_int(entry, "cache_swap_high", Config.Swap.highWaterMark);
    dump_logformat(entry, "logformat", Log::TheConfig);
    dump_access_log(entry, "access_log", Config.Log.accesslogs);
#if ICAP_CLIENT
    dump_access_log(entry, "icap_log", Config.Log.icaplogs);
#endif
    dump_string(entry, "logfile_daemon", Log::TheConfig.logfile_daemon);
    dump_acl_access(entry, "stats_collection", Config.accessList.stats_collection);
    dump_string(entry, "cache_store_log", Config.Log.store);
    dump_string(entry, "cache_swap_state", Config.Log.swap);
    dump_int(entry, "logfile_rotate", Config.Log.rotateNumber);
    dump_string(entry, "mime_table", Config.mimeTablePathname);
    dump_onoff(entry, "log_mime_hdrs", Config.onoff.log_mime_hdrs);
    dump_string(entry, "pid_filename", Config.pidFilename);
    dump_address(entry, "client_netmask", Config.Addrs.client_netmask);
    dump_onoff(entry, "strip_query_terms", Config.onoff.strip_query_terms);
    dump_onoff(entry, "buffered_logs", Config.onoff.buffered_logs);
#if USE_ICMP
    dump_string(entry, "netdb_filename", Config.netdbFilename);
#endif
    dump_string(entry, "cache_log", Debug::cache_log);
    dump_eol(entry, "debug_options", Debug::debugOptions);
    dump_string(entry, "coredump_dir", Config.coredump_dir);
    dump_string(entry, "ftp_user", Config.Ftp.anon_user);
    dump_onoff(entry, "ftp_passive", Config.Ftp.passive);
    dump_onoff(entry, "ftp_epsv_all", Config.Ftp.epsv_all);
    dump_ftp_epsv(entry, "ftp_epsv", Config.accessList.ftp_epsv);
    dump_onoff(entry, "ftp_eprt", Config.Ftp.eprt);
    dump_onoff(entry, "ftp_sanitycheck", Config.Ftp.sanitycheck);
    dump_onoff(entry, "ftp_telnet_protocol", Config.Ftp.telnet);
    dump_string(entry, "diskd_program", Config.Program.diskd);
#if USE_UNLINKD
    dump_string(entry, "unlinkd_program", Config.Program.unlinkd);
#endif
#if USE_ICMP
    dump_string(entry, "pinger_program", Config.pinger.program);
#endif
#if USE_ICMP
    dump_onoff(entry, "pinger_enable", Config.pinger.enable);
#endif
    dump_wordlist(entry, "url_rewrite_program", Config.Program.redirect);
    dump_HelperChildConfig(entry, "url_rewrite_children", Config.redirectChildren);
    dump_onoff(entry, "url_rewrite_host_header", Config.onoff.redir_rewrites_host);
    dump_acl_access(entry, "url_rewrite_access", Config.accessList.redirector);
    dump_onoff(entry, "url_rewrite_bypass", Config.onoff.redirector_bypass);
    dump_TokenOrQuotedString(entry, "url_rewrite_extras", Config.redirector_extras);
    dump_wordlist(entry, "store_id_program", Config.Program.store_id);
    dump_TokenOrQuotedString(entry, "store_id_extras", Config.storeId_extras);
    dump_HelperChildConfig(entry, "store_id_children", Config.storeIdChildren);
    dump_acl_access(entry, "store_id_access", Config.accessList.store_id);
    dump_onoff(entry, "store_id_bypass", Config.onoff.store_id_bypass);
    dump_acl_access(entry, "cache", Config.accessList.noCache);
    dump_acl_access(entry, "send_hit", Config.accessList.sendHit);
    dump_acl_access(entry, "store_miss", Config.accessList.storeMiss);
    dump_time_t(entry, "max_stale", Config.maxStale);
    dump_refreshpattern(entry, "refresh_pattern", Config.Refresh);
    dump_kb_int64_t(entry, "quick_abort_min", Config.quickAbort.min);
    dump_kb_int64_t(entry, "quick_abort_max", Config.quickAbort.max);
    dump_int(entry, "quick_abort_pct", Config.quickAbort.pct);
    dump_b_int64_t(entry, "read_ahead_gap", Config.readAheadGap);
#if USE_HTTP_VIOLATIONS
    dump_time_t(entry, "negative_ttl", Config.negativeTtl);
#endif
    dump_time_t(entry, "positive_dns_ttl", Config.positiveDnsTtl);
    dump_time_t(entry, "negative_dns_ttl", Config.negativeDnsTtl);
    dump_acl_b_size_t(entry, "range_offset_limit", Config.rangeOffsetLimit);
    dump_time_t(entry, "minimum_expiry_time", Config.minimum_expiry_time);
    dump_b_int64_t(entry, "store_avg_object_size", Config.Store.avgObjectSize);
    dump_int(entry, "store_objects_per_bucket", Config.Store.objectsPerBucket);
    dump_b_size_t(entry, "request_header_max_size", Config.maxRequestHeaderSize);
    dump_b_size_t(entry, "reply_header_max_size", Config.maxReplyHeaderSize);
    dump_b_int64_t(entry, "request_body_max_size", Config.maxRequestBodySize);
    dump_b_size_t(entry, "client_request_buffer_max_size", Config.maxRequestBufferSize);
#if USE_HTTP_VIOLATIONS
    dump_acl_access(entry, "broken_posts", Config.accessList.brokenPosts);
#endif
#if FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION
    dump_onoff(entry, "adaptation_uses_indirect_client", Adaptation::Config::use_indirect_client);
#endif
#if USE_HTTP_VIOLATIONS
    dump_onoff(entry, "via", Config.onoff.via);
#endif
    dump_onoff(entry, "ie_refresh", Config.onoff.ie_refresh);
    dump_onoff(entry, "vary_ignore_expire", Config.onoff.vary_ignore_expire);
    dump_onoff(entry, "request_entities", Config.onoff.request_entities);
#if USE_HTTP_VIOLATIONS
    dump_http_header_access(entry, "request_header_access", Config.request_header_access);
#endif
#if USE_HTTP_VIOLATIONS
    dump_http_header_access(entry, "reply_header_access", Config.reply_header_access);
#endif
#if USE_HTTP_VIOLATIONS
    dump_http_header_replace(entry, "request_header_replace", Config.request_header_access);
#endif
#if USE_HTTP_VIOLATIONS
    dump_http_header_replace(entry, "reply_header_replace", Config.reply_header_access);
#endif
    dump_HeaderWithAclList(entry, "request_header_add", Config.request_header_add);
    dump_note(entry, "note", Config.notes);
    dump_tristate(entry, "relaxed_header_parser", Config.onoff.relaxed_header_parser);
    dump_onoff(entry, "collapsed_forwarding", Config.onoff.collapsed_forwarding);
    dump_time_t(entry, "forward_timeout", Config.Timeout.forward);
    dump_time_t(entry, "connect_timeout", Config.Timeout.connect);
    dump_time_t(entry, "peer_connect_timeout", Config.Timeout.peer_connect);
    dump_time_t(entry, "read_timeout", Config.Timeout.read);
    dump_time_t(entry, "write_timeout", Config.Timeout.write);
    dump_time_t(entry, "request_timeout", Config.Timeout.request);
    dump_time_t(entry, "client_idle_pconn_timeout", Config.Timeout.clientIdlePconn);
    dump_time_t(entry, "ftp_client_idle_timeout", Config.Timeout.ftpClientIdle);
    dump_time_t(entry, "client_lifetime", Config.Timeout.lifetime);
    dump_onoff(entry, "half_closed_clients", Config.onoff.half_closed_clients);
    dump_time_t(entry, "server_idle_pconn_timeout", Config.Timeout.serverIdlePconn);
#if USE_IDENT
    dump_time_t(entry, "ident_timeout", Ident::TheConfig.timeout);
#endif
    dump_time_t(entry, "shutdown_lifetime", Config.shutdownLifetime);
    dump_string(entry, "cache_mgr", Config.adminEmail);
    dump_string(entry, "mail_from", Config.EmailFrom);
    dump_eol(entry, "mail_program", Config.EmailProgram);
    dump_string(entry, "cache_effective_user", Config.effectiveUser);
    dump_string(entry, "cache_effective_group", Config.effectiveGroup);
    dump_onoff(entry, "httpd_suppress_version_string", Config.onoff.httpd_suppress_version_string);
    dump_string(entry, "visible_hostname", Config.visibleHostname);
    dump_string(entry, "unique_hostname", Config.uniqueHostname);
    dump_wordlist(entry, "hostname_aliases", Config.hostnameAliases);
    dump_int(entry, "umask", Config.umask);
    dump_time_t(entry, "announce_period", Config.Announce.period);
    dump_string(entry, "announce_host", Config.Announce.host);
    dump_string(entry, "announce_file", Config.Announce.file);
    dump_u_short(entry, "announce_port", Config.Announce.port);
    dump_string(entry, "httpd_accel_surrogate_id", Config.Accel.surrogate_id);
    dump_onoff(entry, "http_accel_surrogate_remote", Config.onoff.surrogate_is_remote);
#if USE_SQUID_ESI
    dump_string(entry, "esi_parser", ESIParser::Type);
#endif
#if USE_DELAY_POOLS
    dump_delay_pool_count(entry, "delay_pools", Config.Delay);
#endif
#if USE_DELAY_POOLS
    dump_delay_pool_class(entry, "delay_class", Config.Delay);
#endif
#if USE_DELAY_POOLS
    dump_delay_pool_access(entry, "delay_access", Config.Delay);
#endif
#if USE_DELAY_POOLS
    dump_delay_pool_rates(entry, "delay_parameters", Config.Delay);
#endif
#if USE_DELAY_POOLS
    dump_u_short(entry, "delay_initial_bucket_level", Config.Delay.initial);
#endif
#if USE_DELAY_POOLS
    dump_client_delay_pool_count(entry, "client_delay_pools", Config.ClientDelay);
#endif
#if USE_DELAY_POOLS
    dump_u_short(entry, "client_delay_initial_bucket_level", Config.ClientDelay.initial);
#endif
#if USE_DELAY_POOLS
    dump_client_delay_pool_rates(entry, "client_delay_parameters", Config.ClientDelay);
#endif
#if USE_DELAY_POOLS
    dump_client_delay_pool_access(entry, "client_delay_access", Config.ClientDelay);
#endif
#if USE_WCCP
    dump_address(entry, "wccp_router", Config.Wccp.router);
#endif
#if USE_WCCPv2
    dump_IpAddress_list(entry, "wccp2_router", Config.Wccp2.router);
#endif
#if USE_WCCP
    dump_int(entry, "wccp_version", Config.Wccp.version);
#endif
#if USE_WCCPv2
    dump_onoff(entry, "wccp2_rebuild_wait", Config.Wccp2.rebuildwait);
#endif
#if USE_WCCPv2
    dump_wccp2_method(entry, "wccp2_forwarding_method", Config.Wccp2.forwarding_method);
#endif
#if USE_WCCPv2
    dump_wccp2_method(entry, "wccp2_return_method", Config.Wccp2.return_method);
#endif
#if USE_WCCPv2
    dump_wccp2_amethod(entry, "wccp2_assignment_method", Config.Wccp2.assignment_method);
#endif
#if USE_WCCPv2
    dump_wccp2_service(entry, "wccp2_service", Config.Wccp2.info);
#endif
#if USE_WCCPv2
    dump_wccp2_service_info(entry, "wccp2_service_info", Config.Wccp2.info);
#endif
#if USE_WCCPv2
    dump_int(entry, "wccp2_weight", Config.Wccp2.weight);
#endif
#if USE_WCCP
    dump_address(entry, "wccp_address", Config.Wccp.address);
#endif
#if USE_WCCPv2
    dump_address(entry, "wccp2_address", Config.Wccp2.address);
#endif
    dump_onoff(entry, "client_persistent_connections", Config.onoff.client_pconns);
    dump_onoff(entry, "server_persistent_connections", Config.onoff.server_pconns);
    dump_onoff(entry, "persistent_connection_after_error", Config.onoff.error_pconns);
    dump_onoff(entry, "detect_broken_pconn", Config.onoff.detect_broken_server_pconns);
#if USE_CACHE_DIGESTS
    dump_onoff(entry, "digest_generation", Config.onoff.digest_generation);
#endif
#if USE_CACHE_DIGESTS
    dump_int(entry, "digest_bits_per_entry", Config.digest.bits_per_entry);
#endif
#if USE_CACHE_DIGESTS
    dump_time_t(entry, "digest_rebuild_period", Config.digest.rebuild_period);
#endif
#if USE_CACHE_DIGESTS
    dump_time_t(entry, "digest_rewrite_period", Config.digest.rewrite_period);
#endif
#if USE_CACHE_DIGESTS
    dump_b_size_t(entry, "digest_swapout_chunk_size", Config.digest.swapout_chunk_size);
#endif
#if USE_CACHE_DIGESTS
    dump_int(entry, "digest_rebuild_chunk_percentage", Config.digest.rebuild_chunk_percentage);
#endif
#if SQUID_SNMP
    dump_u_short(entry, "snmp_port", Config.Port.snmp);
#endif
#if SQUID_SNMP
    dump_acl_access(entry, "snmp_access", Config.accessList.snmp);
#endif
#if SQUID_SNMP
    dump_address(entry, "snmp_incoming_address", Config.Addrs.snmp_incoming);
#endif
#if SQUID_SNMP
    dump_address(entry, "snmp_outgoing_address", Config.Addrs.snmp_outgoing);
#endif
    dump_u_short(entry, "icp_port", Config.Port.icp);
#if USE_HTCP
    dump_u_short(entry, "htcp_port", Config.Port.htcp);
#endif
    dump_onoff(entry, "log_icp_queries", Config.onoff.log_udp);
    dump_address(entry, "udp_incoming_address", Config.Addrs.udp_incoming);
    dump_address(entry, "udp_outgoing_address", Config.Addrs.udp_outgoing);
    dump_onoff(entry, "icp_hit_stale", Config.onoff.icp_hit_stale);
    dump_int(entry, "minimum_direct_hops", Config.minDirectHops);
    dump_int(entry, "minimum_direct_rtt", Config.minDirectRtt);
    dump_int(entry, "netdb_low", Config.Netdb.low);
    dump_int(entry, "netdb_high", Config.Netdb.high);
    dump_time_t(entry, "netdb_ping_period", Config.Netdb.period);
    dump_onoff(entry, "query_icmp", Config.onoff.query_icmp);
    dump_onoff(entry, "test_reachability", Config.onoff.test_reachability);
    dump_int(entry, "icp_query_timeout", Config.Timeout.icp_query);
    dump_int(entry, "maximum_icp_query_timeout", Config.Timeout.icp_query_max);
    dump_int(entry, "minimum_icp_query_timeout", Config.Timeout.icp_query_min);
    dump_time_t(entry, "background_ping_rate", Config.backgroundPingRate);
    dump_wordlist(entry, "mcast_groups", Config.mcast_group_list);
#if MULTICAST_MISS_STREAM
    dump_address(entry, "mcast_miss_addr", Config.mcast_miss.addr);
#endif
#if MULTICAST_MISS_STREAM
    dump_u_short(entry, "mcast_miss_ttl", Config.mcast_miss.ttl);
#endif
#if MULTICAST_MISS_STREAM
    dump_u_short(entry, "mcast_miss_port", Config.mcast_miss.port);
#endif
#if MULTICAST_MISS_STREAM
    dump_string(entry, "mcast_miss_encode_key", Config.mcast_miss.encode_key);
#endif
    dump_int(entry, "mcast_icp_query_timeout", Config.Timeout.mcast_icp_query);
    dump_string(entry, "icon_directory", Config.icons.directory);
    dump_onoff(entry, "global_internal_static", Config.onoff.global_internal_static);
    dump_onoff(entry, "short_icon_urls", Config.icons.use_short_names);
    dump_string(entry, "error_directory", Config.errorDirectory);
#if USE_ERR_LOCALES
    dump_string(entry, "error_default_language", Config.errorDefaultLanguage);
#endif
#if USE_ERR_LOCALES
    dump_onoff(entry, "error_log_languages", Config.errorLogMissingLanguages);
#endif
    dump_string(entry, "err_page_stylesheet", Config.errorStylesheet);
    dump_eol(entry, "err_html_text", Config.errHtmlText);
    dump_onoff(entry, "email_err_data", Config.onoff.emailErrData);
    dump_denyinfo(entry, "deny_info", Config.denyInfoList);
    dump_onoff(entry, "nonhierarchical_direct", Config.onoff.nonhierarchical_direct);
    dump_onoff(entry, "prefer_direct", Config.onoff.prefer_direct);
    dump_onoff(entry, "cache_miss_revalidate", Config.onoff.cache_miss_revalidate);
    dump_acl_access(entry, "always_direct", Config.accessList.AlwaysDirect);
    dump_acl_access(entry, "never_direct", Config.accessList.NeverDirect);
    dump_int(entry, "incoming_udp_average", Config.comm_incoming.udp.average);
    dump_int(entry, "incoming_tcp_average", Config.comm_incoming.tcp.average);
    dump_int(entry, "incoming_dns_average", Config.comm_incoming.dns.average);
    dump_int(entry, "min_udp_poll_cnt", Config.comm_incoming.udp.min_poll);
    dump_int(entry, "min_dns_poll_cnt", Config.comm_incoming.dns.min_poll);
    dump_int(entry, "min_tcp_poll_cnt", Config.comm_incoming.tcp.min_poll);
    dump_string(entry, "accept_filter", Config.accept_filter);
    dump_int(entry, "client_ip_max_connections", Config.client_ip_max_connections);
    dump_b_size_t(entry, "tcp_recv_bufsize", Config.tcpRcvBufsz);
#if ICAP_CLIENT
    dump_onoff(entry, "icap_enable", Adaptation::Icap::TheConfig.onoff);
#endif
#if ICAP_CLIENT
    dump_time_t(entry, "icap_connect_timeout", Adaptation::Icap::TheConfig.connect_timeout_raw);
#endif
#if ICAP_CLIENT
    dump_time_t(entry, "icap_io_timeout", Adaptation::Icap::TheConfig.io_timeout_raw);
#endif
#if ICAP_CLIENT
    dump_icap_service_failure_limit(entry, "icap_service_failure_limit", Adaptation::Icap::TheConfig);
#endif
#if ICAP_CLIENT
    dump_int(entry, "icap_service_revival_delay", Adaptation::Icap::TheConfig.service_revival_delay);
#endif
#if ICAP_CLIENT
    dump_onoff(entry, "icap_preview_enable", Adaptation::Icap::TheConfig.preview_enable);
#endif
#if ICAP_CLIENT
    dump_int(entry, "icap_preview_size", Adaptation::Icap::TheConfig.preview_size);
#endif
#if ICAP_CLIENT
    dump_onoff(entry, "icap_206_enable", Adaptation::Icap::TheConfig.allow206_enable);
#endif
#if ICAP_CLIENT
    dump_int(entry, "icap_default_options_ttl", Adaptation::Icap::TheConfig.default_options_ttl);
#endif
#if ICAP_CLIENT
    dump_onoff(entry, "icap_persistent_connections", Adaptation::Icap::TheConfig.reuse_connections);
#endif
#if USE_ADAPTATION
    dump_onoff(entry, "adaptation_send_client_ip", Adaptation::Config::send_client_ip);
#endif
#if USE_ADAPTATION
    dump_onoff(entry, "adaptation_send_username", Adaptation::Config::send_username);
#endif
#if ICAP_CLIENT
    dump_string(entry, "icap_client_username_header", Adaptation::Icap::TheConfig.client_username_header);
#endif
#if ICAP_CLIENT
    dump_onoff(entry, "icap_client_username_encode", Adaptation::Icap::TheConfig.client_username_encode);
#endif
#if ICAP_CLIENT
    dump_icap_service_type(entry, "icap_service", Adaptation::Icap::TheConfig);
#endif
#if USE_ECAP
    dump_onoff(entry, "ecap_enable", Adaptation::Ecap::TheConfig.onoff);
#endif
#if USE_ECAP
    dump_ecap_service_type(entry, "ecap_service", Adaptation::Ecap::TheConfig);
#endif
#if USE_LOADABLE_MODULES
    dump_wordlist(entry, "loadable_modules", Config.loadable_module_names);
#endif
#if USE_ADAPTATION
    dump_int(entry, "adaptation_service_iteration_limit", Adaptation::Config::service_iteration_limit);
#endif
#if USE_ADAPTATION
    dump_string(entry, "adaptation_masterx_shared_names", Adaptation::Config::masterx_shared_name);
#endif
#if USE_ADAPTATION
    dump_note(entry, "adaptation_meta", Adaptation::Config::metaHeaders);
#endif
#if ICAP_CLIENT
    dump_acl_access(entry, "icap_retry", Adaptation::Icap::TheConfig.repeat);
#endif
#if ICAP_CLIENT
    dump_int(entry, "icap_retry_limit", Adaptation::Icap::TheConfig.repeat_limit);
#endif
    dump_onoff(entry, "check_hostnames", Config.onoff.check_hostnames);
    dump_onoff(entry, "allow_underscore", Config.onoff.allow_underscore);
    dump_time_msec(entry, "dns_retransmit_interval", Config.Timeout.idns_retransmit);
    dump_time_msec(entry, "dns_timeout", Config.Timeout.idns_query);
    dump_b_ssize_t(entry, "dns_packet_max", Config.dns.packet_max);
    dump_onoff(entry, "dns_defnames", Config.onoff.res_defnames);
    dump_onoff(entry, "dns_multicast_local", Config.onoff.dns_mdns);
    dump_wordlist(entry, "dns_nameservers", Config.dns_nameservers);
    dump_string(entry, "hosts_file", Config.etcHostsPath);
    dump_string(entry, "append_domain", Config.appendDomain);
    dump_onoff(entry, "ignore_unknown_nameservers", Config.onoff.ignore_unknown_nameservers);
    dump_onoff(entry, "dns_v4_first", Config.dns.v4_first);
    dump_int(entry, "ipcache_size", Config.ipcache.size);
    dump_int(entry, "ipcache_low", Config.ipcache.low);
    dump_int(entry, "ipcache_high", Config.ipcache.high);
    dump_int(entry, "fqdncache_size", Config.fqdncache.size);
    dump_configuration_includes_quoted_values(entry, "configuration_includes_quoted_values", ConfigParser::RecognizeQuotedValues);
    dump_onoff(entry, "memory_pools", Config.onoff.mem_pools);
    dump_b_int64_t(entry, "memory_pools_limit", Config.MemPools.limit);
    dump_string(entry, "forwarded_for", opt_forwarded_for);
    dump_cachemgrpasswd(entry, "cachemgr_passwd", Config.passwd_list);
    dump_onoff(entry, "client_db", Config.onoff.client_db);
    dump_onoff(entry, "refresh_all_ims", Config.onoff.refresh_all_ims);
#if USE_HTTP_VIOLATIONS
    dump_onoff(entry, "reload_into_ims", Config.onoff.reload_into_ims);
#endif
    dump_int(entry, "connect_retries", Config.connect_retries);
    dump_onoff(entry, "retry_on_error", Config.retry.onerror);
    dump_string(entry, "as_whois_server", Config.as_whois_server);
    dump_onoff(entry, "offline_mode", Config.onoff.offline);
    dump_uri_whitespace(entry, "uri_whitespace", Config.uri_whitespace);
    dump_string(entry, "chroot", Config.chroot_dir);
    dump_onoff(entry, "balance_on_multiple_ip", Config.onoff.balance_on_multiple_ip);
    dump_pipelinePrefetch(entry, "pipeline_prefetch", Config.pipeline_max_prefetch);
    dump_int(entry, "high_response_time_warning", Config.warnings.high_rptm);
    dump_int(entry, "high_page_fault_warning", Config.warnings.high_pf);
#if HAVE_MSTATS&&HAVE_GNUMALLOC_H
    dump_b_size_t(entry, "high_memory_warning", Config.warnings.high_memory);
#endif
    dump_int(entry, "sleep_after_fork", Config.sleep_after_fork);
#if _SQUID_WINDOWS_
    dump_onoff(entry, "windows_ipaddrchangemonitor", Config.onoff.WIN32_IpAddrChangeMonitor);
#endif
#if USE_SQUID_EUI
    dump_onoff(entry, "eui_lookup", Eui::TheConfig.euiLookup);
#endif
    dump_int(entry, "max_filedescriptors", Config.max_filedescriptors);
}

static void
free_all(void)
{
    debugs(5, 4, HERE);
    free_int(&Config.workers);
    free_CpuAffinityMap(&Config.cpuAffinityMap);
#if USE_AUTH
    free_authparam(&Auth::TheConfig);
#endif
    free_time_t(&Config.authenticateGCInterval);
    free_time_t(&Config.authenticateTTL);
    free_time_t(&Config.authenticateIpTTL);
    free_externalAclHelper(&Config.externalAclHelperList);
    free_acl(&Config.aclList);
    free_acl_access(&Config.accessList.proxyProtocol);
#if FOLLOW_X_FORWARDED_FOR
    free_acl_access(&Config.accessList.followXFF);
#endif
#if FOLLOW_X_FORWARDED_FOR
    free_onoff(&Config.onoff.acl_uses_indirect_client);
#endif
#if FOLLOW_X_FORWARDED_FOR&&USE_DELAY_POOLS
    free_onoff(&Config.onoff.delay_pool_uses_indirect_client);
#endif
#if FOLLOW_X_FORWARDED_FOR
    free_onoff(&Config.onoff.log_uses_indirect_client);
#endif
#if FOLLOW_X_FORWARDED_FOR&&LINUX_NETFILTER
    free_onoff(&Config.onoff.tproxy_uses_indirect_client);
#endif
    free_acl_access(&Config.accessList.spoof_client_ip);
    free_acl_access(&Config.accessList.http);
    free_acl_access(&Config.accessList.adapted_http);
    free_acl_access(&Config.accessList.reply);
    free_acl_access(&Config.accessList.icp);
#if USE_HTCP
    free_acl_access(&Config.accessList.htcp);
#endif
#if USE_HTCP
    free_acl_access(&Config.accessList.htcp_clr);
#endif
    free_acl_access(&Config.accessList.miss);
#if USE_IDENT
    free_acl_access(&Ident::TheConfig.identLookup);
#endif
    free_acl_b_size_t(&Config.ReplyBodySize);
    free_PortCfg(&HttpPortList);
#if USE_OPENSSL
    free_PortCfg(&HttpsPortList);
#endif
    free_PortCfg(&FtpPortList);
    free_acl_tos(&Ip::Qos::TheConfig.tosToServer);
    free_acl_tos(&Ip::Qos::TheConfig.tosToClient);
#if SO_MARK&&USE_LIBCAP
    free_acl_nfmark(&Ip::Qos::TheConfig.nfmarkToServer);
#endif
#if SO_MARK&&USE_LIBCAP
    free_acl_nfmark(&Ip::Qos::TheConfig.nfmarkToClient);
#endif
#if USE_QOS_TOS
    free_QosConfig(&Ip::Qos::TheConfig);
#endif
    free_acl_address(&Config.accessList.outgoing_address);
    free_onoff(&Config.onoff.hostStrictVerify);
    free_onoff(&Config.onoff.client_dst_passthru);
#if USE_OPENSSL
    free_onoff(&Config.SSL.unclean_shutdown);
#endif
#if USE_OPENSSL
    free_string(&Config.SSL.ssl_engine);
#endif
#if USE_OPENSSL
    free_string(&Config.ssl_client.cert);
#endif
#if USE_OPENSSL
    free_string(&Config.ssl_client.key);
#endif
#if USE_OPENSSL
    free_int(&Config.ssl_client.version);
#endif
#if USE_OPENSSL
    free_string(&Config.ssl_client.options);
#endif
#if USE_OPENSSL
    free_string(&Config.ssl_client.cipher);
#endif
#if USE_OPENSSL
    free_string(&Config.ssl_client.cafile);
#endif
#if USE_OPENSSL
    free_string(&Config.ssl_client.capath);
#endif
#if USE_OPENSSL
    free_int(&Config.SSL.session_ttl);
#endif
#if USE_OPENSSL
    free_b_size_t(&Config.SSL.sessionCacheSize);
#endif
#if USE_OPENSSL
    free_string(&Config.ssl_client.foreignIntermediateCertsPath);
#endif
#if USE_OPENSSL
    free_string(&Config.SSL.certSignHash);
#endif
#if USE_OPENSSL
    free_sslproxy_ssl_bump(&Config.accessList.ssl_bump);
#endif
#if USE_OPENSSL
    free_string(&Config.ssl_client.flags);
#endif
#if USE_OPENSSL
    free_acl_access(&Config.ssl_client.cert_error);
#endif
#if USE_OPENSSL
    free_sslproxy_cert_sign(&Config.ssl_client.cert_sign);
#endif
#if USE_OPENSSL
    free_sslproxy_cert_adapt(&Config.ssl_client.cert_adapt);
#endif
#if USE_OPENSSL
    free_string(&Config.Program.ssl_password);
#endif
#if USE_SSL_CRTD
    free_eol(&Ssl::TheConfig.ssl_crtd);
#endif
#if USE_SSL_CRTD
    free_HelperChildConfig(&Ssl::TheConfig.ssl_crtdChildren);
#endif
#if USE_OPENSSL
    free_eol(&Ssl::TheConfig.ssl_crt_validator);
#endif
#if USE_OPENSSL
    free_HelperChildConfig(&Ssl::TheConfig.ssl_crt_validator_Children);
#endif
    free_peer(&Config.peers);
    free_time_t(&Config.Timeout.deadPeer);
    free_int(&Config.forward_max_tries);
    free_b_size_t(&Config.memMaxSize);
    free_b_size_t(&Config.Store.maxInMemObjSize);
    free_YesNoNone(&Config.memShared);
    free_memcachemode(&Config);
    free_removalpolicy(&Config.memPolicy);
    free_removalpolicy(&Config.replPolicy);
    free_b_int64_t(&Config.Store.minObjectSize);
    free_b_int64_t(&Config.Store.maxObjectSize);
    free_cachedir(&Config.cacheSwap);
    free_string(&Config.store_dir_select_algorithm);
    free_int(&Config.max_open_disk_fds);
    free_int(&Config.Swap.lowWaterMark);
    free_int(&Config.Swap.highWaterMark);
    free_logformat(&Log::TheConfig);
    free_access_log(&Config.Log.accesslogs);
#if ICAP_CLIENT
    free_access_log(&Config.Log.icaplogs);
#endif
    free_string(&Log::TheConfig.logfile_daemon);
    free_acl_access(&Config.accessList.stats_collection);
    free_string(&Config.Log.store);
    free_string(&Config.Log.swap);
    free_int(&Config.Log.rotateNumber);
    free_string(&Config.mimeTablePathname);
    free_onoff(&Config.onoff.log_mime_hdrs);
    free_string(&Config.pidFilename);
    free_address(&Config.Addrs.client_netmask);
    free_onoff(&Config.onoff.strip_query_terms);
    free_onoff(&Config.onoff.buffered_logs);
#if USE_ICMP
    free_string(&Config.netdbFilename);
#endif
    free_string(&Debug::cache_log);
    free_eol(&Debug::debugOptions);
    free_string(&Config.coredump_dir);
    free_string(&Config.Ftp.anon_user);
    free_onoff(&Config.Ftp.passive);
    free_onoff(&Config.Ftp.epsv_all);
    free_ftp_epsv(&Config.accessList.ftp_epsv);
    free_onoff(&Config.Ftp.eprt);
    free_onoff(&Config.Ftp.sanitycheck);
    free_onoff(&Config.Ftp.telnet);
    free_string(&Config.Program.diskd);
#if USE_UNLINKD
    free_string(&Config.Program.unlinkd);
#endif
#if USE_ICMP
    free_string(&Config.pinger.program);
#endif
#if USE_ICMP
    free_onoff(&Config.pinger.enable);
#endif
    free_wordlist(&Config.Program.redirect);
    free_HelperChildConfig(&Config.redirectChildren);
    free_onoff(&Config.onoff.redir_rewrites_host);
    free_acl_access(&Config.accessList.redirector);
    free_onoff(&Config.onoff.redirector_bypass);
    free_TokenOrQuotedString(&Config.redirector_extras);
    free_wordlist(&Config.Program.store_id);
    free_TokenOrQuotedString(&Config.storeId_extras);
    free_HelperChildConfig(&Config.storeIdChildren);
    free_acl_access(&Config.accessList.store_id);
    free_onoff(&Config.onoff.store_id_bypass);
    free_acl_access(&Config.accessList.noCache);
    free_acl_access(&Config.accessList.sendHit);
    free_acl_access(&Config.accessList.storeMiss);
    free_time_t(&Config.maxStale);
    free_refreshpattern(&Config.Refresh);
    free_kb_int64_t(&Config.quickAbort.min);
    free_kb_int64_t(&Config.quickAbort.max);
    free_int(&Config.quickAbort.pct);
    free_b_int64_t(&Config.readAheadGap);
#if USE_HTTP_VIOLATIONS
    free_time_t(&Config.negativeTtl);
#endif
    free_time_t(&Config.positiveDnsTtl);
    free_time_t(&Config.negativeDnsTtl);
    free_acl_b_size_t(&Config.rangeOffsetLimit);
    free_time_t(&Config.minimum_expiry_time);
    free_b_int64_t(&Config.Store.avgObjectSize);
    free_int(&Config.Store.objectsPerBucket);
    free_b_size_t(&Config.maxRequestHeaderSize);
    free_b_size_t(&Config.maxReplyHeaderSize);
    free_b_int64_t(&Config.maxRequestBodySize);
    free_b_size_t(&Config.maxRequestBufferSize);
#if USE_HTTP_VIOLATIONS
    free_acl_access(&Config.accessList.brokenPosts);
#endif
#if FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION
    free_onoff(&Adaptation::Config::use_indirect_client);
#endif
#if USE_HTTP_VIOLATIONS
    free_onoff(&Config.onoff.via);
#endif
    free_onoff(&Config.onoff.ie_refresh);
    free_onoff(&Config.onoff.vary_ignore_expire);
    free_onoff(&Config.onoff.request_entities);
#if USE_HTTP_VIOLATIONS
    free_http_header_access(&Config.request_header_access);
#endif
#if USE_HTTP_VIOLATIONS
    free_http_header_access(&Config.reply_header_access);
#endif
#if USE_HTTP_VIOLATIONS
    free_http_header_replace(&Config.request_header_access);
#endif
#if USE_HTTP_VIOLATIONS
    free_http_header_replace(&Config.reply_header_access);
#endif
    free_HeaderWithAclList(&Config.request_header_add);
    free_note(&Config.notes);
    free_tristate(&Config.onoff.relaxed_header_parser);
    free_onoff(&Config.onoff.collapsed_forwarding);
    free_time_t(&Config.Timeout.forward);
    free_time_t(&Config.Timeout.connect);
    free_time_t(&Config.Timeout.peer_connect);
    free_time_t(&Config.Timeout.read);
    free_time_t(&Config.Timeout.write);
    free_time_t(&Config.Timeout.request);
    free_time_t(&Config.Timeout.clientIdlePconn);
    free_time_t(&Config.Timeout.ftpClientIdle);
    free_time_t(&Config.Timeout.lifetime);
    free_onoff(&Config.onoff.half_closed_clients);
    free_time_t(&Config.Timeout.serverIdlePconn);
#if USE_IDENT
    free_time_t(&Ident::TheConfig.timeout);
#endif
    free_time_t(&Config.shutdownLifetime);
    free_string(&Config.adminEmail);
    free_string(&Config.EmailFrom);
    free_eol(&Config.EmailProgram);
    free_string(&Config.effectiveUser);
    free_string(&Config.effectiveGroup);
    free_onoff(&Config.onoff.httpd_suppress_version_string);
    free_string(&Config.visibleHostname);
    free_string(&Config.uniqueHostname);
    free_wordlist(&Config.hostnameAliases);
    free_int(&Config.umask);
    free_time_t(&Config.Announce.period);
    free_string(&Config.Announce.host);
    free_string(&Config.Announce.file);
    free_u_short(&Config.Announce.port);
    free_string(&Config.Accel.surrogate_id);
    free_onoff(&Config.onoff.surrogate_is_remote);
#if USE_SQUID_ESI
    free_string(&ESIParser::Type);
#endif
#if USE_DELAY_POOLS
    free_delay_pool_count(&Config.Delay);
#endif
#if USE_DELAY_POOLS
    free_delay_pool_class(&Config.Delay);
#endif
#if USE_DELAY_POOLS
    free_delay_pool_access(&Config.Delay);
#endif
#if USE_DELAY_POOLS
    free_delay_pool_rates(&Config.Delay);
#endif
#if USE_DELAY_POOLS
    free_u_short(&Config.Delay.initial);
#endif
#if USE_DELAY_POOLS
    free_client_delay_pool_count(&Config.ClientDelay);
#endif
#if USE_DELAY_POOLS
    free_u_short(&Config.ClientDelay.initial);
#endif
#if USE_DELAY_POOLS
    free_client_delay_pool_rates(&Config.ClientDelay);
#endif
#if USE_DELAY_POOLS
    free_client_delay_pool_access(&Config.ClientDelay);
#endif
#if USE_WCCP
    free_address(&Config.Wccp.router);
#endif
#if USE_WCCPv2
    free_IpAddress_list(&Config.Wccp2.router);
#endif
#if USE_WCCP
    free_int(&Config.Wccp.version);
#endif
#if USE_WCCPv2
    free_onoff(&Config.Wccp2.rebuildwait);
#endif
#if USE_WCCPv2
    free_wccp2_method(&Config.Wccp2.forwarding_method);
#endif
#if USE_WCCPv2
    free_wccp2_method(&Config.Wccp2.return_method);
#endif
#if USE_WCCPv2
    free_wccp2_amethod(&Config.Wccp2.assignment_method);
#endif
#if USE_WCCPv2
    free_wccp2_service(&Config.Wccp2.info);
#endif
#if USE_WCCPv2
    free_wccp2_service_info(&Config.Wccp2.info);
#endif
#if USE_WCCPv2
    free_int(&Config.Wccp2.weight);
#endif
#if USE_WCCP
    free_address(&Config.Wccp.address);
#endif
#if USE_WCCPv2
    free_address(&Config.Wccp2.address);
#endif
    free_onoff(&Config.onoff.client_pconns);
    free_onoff(&Config.onoff.server_pconns);
    free_onoff(&Config.onoff.error_pconns);
    free_onoff(&Config.onoff.detect_broken_server_pconns);
#if USE_CACHE_DIGESTS
    free_onoff(&Config.onoff.digest_generation);
#endif
#if USE_CACHE_DIGESTS
    free_int(&Config.digest.bits_per_entry);
#endif
#if USE_CACHE_DIGESTS
    free_time_t(&Config.digest.rebuild_period);
#endif
#if USE_CACHE_DIGESTS
    free_time_t(&Config.digest.rewrite_period);
#endif
#if USE_CACHE_DIGESTS
    free_b_size_t(&Config.digest.swapout_chunk_size);
#endif
#if USE_CACHE_DIGESTS
    free_int(&Config.digest.rebuild_chunk_percentage);
#endif
#if SQUID_SNMP
    free_u_short(&Config.Port.snmp);
#endif
#if SQUID_SNMP
    free_acl_access(&Config.accessList.snmp);
#endif
#if SQUID_SNMP
    free_address(&Config.Addrs.snmp_incoming);
#endif
#if SQUID_SNMP
    free_address(&Config.Addrs.snmp_outgoing);
#endif
    free_u_short(&Config.Port.icp);
#if USE_HTCP
    free_u_short(&Config.Port.htcp);
#endif
    free_onoff(&Config.onoff.log_udp);
    free_address(&Config.Addrs.udp_incoming);
    free_address(&Config.Addrs.udp_outgoing);
    free_onoff(&Config.onoff.icp_hit_stale);
    free_int(&Config.minDirectHops);
    free_int(&Config.minDirectRtt);
    free_int(&Config.Netdb.low);
    free_int(&Config.Netdb.high);
    free_time_t(&Config.Netdb.period);
    free_onoff(&Config.onoff.query_icmp);
    free_onoff(&Config.onoff.test_reachability);
    free_int(&Config.Timeout.icp_query);
    free_int(&Config.Timeout.icp_query_max);
    free_int(&Config.Timeout.icp_query_min);
    free_time_t(&Config.backgroundPingRate);
    free_wordlist(&Config.mcast_group_list);
#if MULTICAST_MISS_STREAM
    free_address(&Config.mcast_miss.addr);
#endif
#if MULTICAST_MISS_STREAM
    free_u_short(&Config.mcast_miss.ttl);
#endif
#if MULTICAST_MISS_STREAM
    free_u_short(&Config.mcast_miss.port);
#endif
#if MULTICAST_MISS_STREAM
    free_string(&Config.mcast_miss.encode_key);
#endif
    free_int(&Config.Timeout.mcast_icp_query);
    free_string(&Config.icons.directory);
    free_onoff(&Config.onoff.global_internal_static);
    free_onoff(&Config.icons.use_short_names);
    free_string(&Config.errorDirectory);
#if USE_ERR_LOCALES
    free_string(&Config.errorDefaultLanguage);
#endif
#if USE_ERR_LOCALES
    free_onoff(&Config.errorLogMissingLanguages);
#endif
    free_string(&Config.errorStylesheet);
    free_eol(&Config.errHtmlText);
    free_onoff(&Config.onoff.emailErrData);
    free_denyinfo(&Config.denyInfoList);
    free_onoff(&Config.onoff.nonhierarchical_direct);
    free_onoff(&Config.onoff.prefer_direct);
    free_onoff(&Config.onoff.cache_miss_revalidate);
    free_acl_access(&Config.accessList.AlwaysDirect);
    free_acl_access(&Config.accessList.NeverDirect);
    free_int(&Config.comm_incoming.udp.average);
    free_int(&Config.comm_incoming.tcp.average);
    free_int(&Config.comm_incoming.dns.average);
    free_int(&Config.comm_incoming.udp.min_poll);
    free_int(&Config.comm_incoming.dns.min_poll);
    free_int(&Config.comm_incoming.tcp.min_poll);
    free_string(&Config.accept_filter);
    free_int(&Config.client_ip_max_connections);
    free_b_size_t(&Config.tcpRcvBufsz);
#if ICAP_CLIENT
    free_onoff(&Adaptation::Icap::TheConfig.onoff);
#endif
#if ICAP_CLIENT
    free_time_t(&Adaptation::Icap::TheConfig.connect_timeout_raw);
#endif
#if ICAP_CLIENT
    free_time_t(&Adaptation::Icap::TheConfig.io_timeout_raw);
#endif
#if ICAP_CLIENT
    free_icap_service_failure_limit(&Adaptation::Icap::TheConfig);
#endif
#if ICAP_CLIENT
    free_int(&Adaptation::Icap::TheConfig.service_revival_delay);
#endif
#if ICAP_CLIENT
    free_onoff(&Adaptation::Icap::TheConfig.preview_enable);
#endif
#if ICAP_CLIENT
    free_int(&Adaptation::Icap::TheConfig.preview_size);
#endif
#if ICAP_CLIENT
    free_onoff(&Adaptation::Icap::TheConfig.allow206_enable);
#endif
#if ICAP_CLIENT
    free_int(&Adaptation::Icap::TheConfig.default_options_ttl);
#endif
#if ICAP_CLIENT
    free_onoff(&Adaptation::Icap::TheConfig.reuse_connections);
#endif
#if USE_ADAPTATION
    free_onoff(&Adaptation::Config::send_client_ip);
#endif
#if USE_ADAPTATION
    free_onoff(&Adaptation::Config::send_username);
#endif
#if ICAP_CLIENT
    free_string(&Adaptation::Icap::TheConfig.client_username_header);
#endif
#if ICAP_CLIENT
    free_onoff(&Adaptation::Icap::TheConfig.client_username_encode);
#endif
#if ICAP_CLIENT
    free_icap_service_type(&Adaptation::Icap::TheConfig);
#endif
#if USE_ECAP
    free_onoff(&Adaptation::Ecap::TheConfig.onoff);
#endif
#if USE_ECAP
    free_ecap_service_type(&Adaptation::Ecap::TheConfig);
#endif
#if USE_LOADABLE_MODULES
    free_wordlist(&Config.loadable_module_names);
#endif
#if USE_ADAPTATION
    free_int(&Adaptation::Config::service_iteration_limit);
#endif
#if USE_ADAPTATION
    free_string(&Adaptation::Config::masterx_shared_name);
#endif
#if USE_ADAPTATION
    free_note(&Adaptation::Config::metaHeaders);
#endif
#if ICAP_CLIENT
    free_acl_access(&Adaptation::Icap::TheConfig.repeat);
#endif
#if ICAP_CLIENT
    free_int(&Adaptation::Icap::TheConfig.repeat_limit);
#endif
    free_onoff(&Config.onoff.check_hostnames);
    free_onoff(&Config.onoff.allow_underscore);
    free_time_msec(&Config.Timeout.idns_retransmit);
    free_time_msec(&Config.Timeout.idns_query);
    free_b_ssize_t(&Config.dns.packet_max);
    free_onoff(&Config.onoff.res_defnames);
    free_onoff(&Config.onoff.dns_mdns);
    free_wordlist(&Config.dns_nameservers);
    free_string(&Config.etcHostsPath);
    free_string(&Config.appendDomain);
    free_onoff(&Config.onoff.ignore_unknown_nameservers);
    free_onoff(&Config.dns.v4_first);
    free_int(&Config.ipcache.size);
    free_int(&Config.ipcache.low);
    free_int(&Config.ipcache.high);
    free_int(&Config.fqdncache.size);
    free_configuration_includes_quoted_values(&ConfigParser::RecognizeQuotedValues);
    free_onoff(&Config.onoff.mem_pools);
    free_b_int64_t(&Config.MemPools.limit);
    free_string(&opt_forwarded_for);
    free_cachemgrpasswd(&Config.passwd_list);
    free_onoff(&Config.onoff.client_db);
    free_onoff(&Config.onoff.refresh_all_ims);
#if USE_HTTP_VIOLATIONS
    free_onoff(&Config.onoff.reload_into_ims);
#endif
    free_int(&Config.connect_retries);
    free_onoff(&Config.retry.onerror);
    free_string(&Config.as_whois_server);
    free_onoff(&Config.onoff.offline);
    free_uri_whitespace(&Config.uri_whitespace);
    free_string(&Config.chroot_dir);
    free_onoff(&Config.onoff.balance_on_multiple_ip);
    free_pipelinePrefetch(&Config.pipeline_max_prefetch);
    free_int(&Config.warnings.high_rptm);
    free_int(&Config.warnings.high_pf);
#if HAVE_MSTATS&&HAVE_GNUMALLOC_H
    free_b_size_t(&Config.warnings.high_memory);
#endif
    free_int(&Config.sleep_after_fork);
#if _SQUID_WINDOWS_
    free_onoff(&Config.onoff.WIN32_IpAddrChangeMonitor);
#endif
#if USE_SQUID_EUI
    free_onoff(&Eui::TheConfig.euiLookup);
#endif
    free_int(&Config.max_filedescriptors);
}

